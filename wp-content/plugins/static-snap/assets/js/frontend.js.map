{"version":3,"file":"frontend.js","mappings":";;;;;;;;;;;;;;;AAAA,MAAMA,SAAS,GAAG;EAChBC,0BAA0B,EAAE,kCAAkC;EAC9DC,4BAA4B,EAAE;AAChC,CAAC;AAEM,MAAMC,MAAM,GAAG;EACpBC,oBAAoB,EAAE,4BAA4B;EAClDC,uBAAuB,EAAE;AAC3B,CAAC;AAED,iEAAeL,SAAS;;;;;;;;;;;;;;;;;ACTa;AAEC;;AAKtC;AAC2B;AACI;;AAiBhB,MAAeO,QAAQ,CAAC;EAC3BC,KAAK,GAAuC,IAAI;EAChDC,QAAQ,GAAW,gCAAgC;EACnDC,oBAAoB,GAAW,iBAAiB;;EAE1D;EACAC,WAAWA,CAACF,QAAiB,EAAE;IAC7B,IAAIA,QAAQ,EAAE;MACZ,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IAC1B;IAEA,IAAI,CAAC,YAAY,EAAE,WAAW,CAAC,CAACG,QAAQ,CAACC,wBAAwB,CAACC,YAAY,CAAC,EAAE;MAC/E,IAAID,wBAAwB,CAACC,YAAY,KAAK,WAAW,EAAE;QACzD,IAAI,CAACC,mBAAmB,CAAC,CAAC;MAC5B,CAAC,MAAM,IAAIF,wBAAwB,CAACC,YAAY,KAAK,YAAY,EAAE;QACjE,IAAI,CAACE,cAAc,CAAC,CAAC;MACvB;IACF;IAEA,IAAI,CAACC,UAAU,CAAC,CAAC;IACjB;EACF;EACA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;EAQE;AACF;AACA;AACA;AACA;AACA;;EAGE;AACF;AACA;AACA;AACA;EACYC,eAAe,GACvBC,YAA+D,IACvC;IACxB,MAAMC,eAAe,GAAG;MACtBC,QAAQ,EAAE;QACRC,KAAK,EAAEhB,mDAAE,CAAC,6CAA6C,EAAE,aAAa,CAAC;QACvEiB,OAAO,EAAEjB,mDAAE,CAAC,6BAA6B,EAAE,aAAa,CAAC;QACzDkB,QAAQ,EAAElB,mDAAE,CAAC,yBAAyB,EAAE,aAAa,CAAC;QACtDmB,OAAO,EAAEnB,mDAAE,CAAC,iCAAiC,EAAE,aAAa;MAC9D;IACF,CAAC;IACD,IAAI,CAACa,YAAY,CAACO,IAAI,IAAIP,YAAY,CAACO,IAAI,KAAK,MAAM,EAAE;MACtD,OAAON,eAAe;IACxB;;IAEA;IACA,OAAO;MAAE,GAAGA,eAAe;MAAE,GAAGD,YAAY,CAACQ,IAAI,CAACC,WAAW,EAAEC;IAAsB,CAAC;EACxF,CAAC;;EAED;AACF;AACA;AACA;EACYC,wBAAwB,GAAIC,IAAqB,IAAoC;IAC7F,MAAMC,sBAAqD,GAAG;MAC5DC,aAAa,EAAE3B,mDAAE,CAAC,6CAA6C,EAAE,aAAa,CAAC;MAC/E4B,eAAe,EAAE5B,mDAAE,CAAC,6BAA6B,EAAE,aAAa,CAAC;MACjE6B,sBAAsB,EAAE7B,mDAAE,CAAC,yBAAyB,EAAE,aAAa,CAAC;MACpE8B,eAAe,EAAE9B,mDAAE,CAAC,iCAAiC,EAAE,aAAa,CAAC;MACrEoB,IAAI,EAAE;IACR,CAAC;IACD,MAAMW,eAAe,GAAGN,IAAI,CAACO,OAAO,EAAEC,4BAA4B;IAClE,IAAI,CAACF,eAAe,EAAE;MACpB,OAAOL,sBAAsB;IAC/B;IAEA,IAAI;MACF,OAAO;QAAE,GAAGA,sBAAsB;QAAE,GAAGQ,IAAI,CAACC,KAAK,CAACJ,eAAe;MAAE,CAAC;IACtE,CAAC,CAAC,OAAOK,EAAE,EAAE;MACX,OAAOV,sBAAsB;IAC/B;EACF,CAAC;EAESW,0BAA0B,GAAGA,CACrCZ,IAAqB,EACrBL,IAAkC,KACvB;IACX,MAAMW,eAAe,GAAG,IAAI,CAACP,wBAAwB,CAACC,IAAI,CAAC;;IAE3D;IACA,IAAIM,eAAe,CAACX,IAAI,KAAK,UAAU,IAAIA,IAAI,KAAK,SAAS,IAAIW,eAAe,CAACO,YAAY,EAAE;MAC7F;IAAA;IAGF,MAAMC,UAAwD,GAAG;MAC/DvB,KAAK,EAAEe,eAAe,CAACJ,aAAa;MACpCa,WAAW,EAAET,eAAe,CAACF,sBAAsB;MACnDY,aAAa,EAAEV,eAAe,CAACH,eAAe;MAC9CT,OAAO,EAAEY,eAAe,CAACD;IAC3B,CAAC;IAED,OAAOS,UAAU,CAACnB,IAAI,CAAC,IAAI,EAAE;EAC/B,CAAC;EAESV,cAAc,GAAGA,CAAA,KAAM;IAC/B,MAAMgC,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IAC/CF,MAAM,CAACG,GAAG,GAAG,qCAAqC;IAClDH,MAAM,CAACI,KAAK,GAAG,IAAI;IACnBJ,MAAM,CAACK,KAAK,GAAG,IAAI;IACnBL,MAAM,CAACtB,IAAI,GAAG,QAAQ;IACtBuB,QAAQ,CAACK,IAAI,CAACC,WAAW,CAACP,MAAM,CAAC;EACnC,CAAC;EAESjC,mBAAmB,GAAGA,CAAA,KAAM;IACpC,MAAMiC,MAAM,GAAGC,QAAQ,CAACC,aAAa,CAAC,QAAQ,CAAC;IAC/CF,MAAM,CAACG,GAAG,GAAG,kDAAkDtC,wBAAwB,CAAC2C,gBAAgB,EAAE;IAC1GR,MAAM,CAACI,KAAK,GAAG,IAAI;IACnBJ,MAAM,CAACK,KAAK,GAAG,IAAI;IACnBJ,QAAQ,CAACK,IAAI,CAACC,WAAW,CAACP,MAAM,CAAC;EACnC,CAAC;EAEMS,QAAQ,GAAGA,CAAA,KAAmC;IACnD;IACA,OAAOR,QAAQ,CAACS,gBAAgB,CAAC,IAAI,CAACjD,QAAQ,CAAC;EACjD,CAAC;;EAED;AACF;AACA;AACA;EACSkD,kBAAkB,GAAI5B,IAAqB,IAAW;IAC3D6B,UAAU,CAAC,MAAM;MACfC,MAAM,CAAC9B,IAAI,CAAC,CAAC+B,GAAG,CAAC,QAAQ,CAAC;IAC5B,CAAC,EAAE,GAAG,CAAC;EACT,CAAC;;EAED;AACF;AACA;EACS7C,UAAU,GAAGA,CAAA,KAAM;IACxB,IAAI,CAACT,KAAK,GAAG,IAAI,CAACiD,QAAQ,CAAC,CAAC;IAE5B,IAAI,CAACjD,KAAK,CAACuD,OAAO,CAAEhC,IAAI,IAAK;MAC3B;MACA,IAAIA,IAAI,CAACiC,YAAY,CAAC,8BAA8B,CAAC,KAAK,MAAM,EAAE;QAChE;MACF;MACA;MACA,IAAI,CAACL,kBAAkB,CAAC5B,IAAI,CAAC;MAC7B;;MAEA;MACA,IAAIlB,wBAAwB,CAACC,YAAY,KAAK,YAAY,EAAE;QAC1D,MAAMmD,gBAAgB,GAAGhB,QAAQ,CAACC,aAAa,CAAC,mBAAmB,CAAC;QACpEe,gBAAgB,CAACC,YAAY,CAAC,aAAa,EAAErD,wBAAwB,CAAC2C,gBAAgB,CAAC;QACvFS,gBAAgB,CAACC,YAAY,CAAC,gBAAgB,EAAE,MAAM,CAAC;QAEvDnC,IAAI,CAACwB,WAAW,CAACU,gBAAgB,CAAC;QAClC,IAAI,CAACE,oBAAoB,CAACpC,IAAI,EAAEkC,gBAAgB,CAAC;MACnD;MAEAlC,IAAI,CAACqC,gBAAgB,CAAC,QAAQ,EAAGC,CAAC,IAAK,IAAI,CAACC,MAAM,CAACD,CAAC,EAAEtC,IAAI,CAAC,CAAC;MAC5D;MACAA,IAAI,CAACmC,YAAY,CAAC,8BAA8B,EAAE,MAAM,CAAC;IAC3D,CAAC,CAAC;EACJ,CAAC;EAESC,oBAAoB,GAAGA,CAACpC,IAAqB,EAAEkC,gBAAqB,KAAK;IACjF,IAAIM,YAAY,GAAG,KAAK;IACxB,IAAIC,SAAS,GAAG,KAAK;IACrB,MAAMC,SAAS,GAAG,IAAI,CAAC,CAAC;;IAExBR,gBAAgB,CAACG,gBAAgB,CAAC,0BAA0B,EAAE,YAAY;MACxE,IAAII,SAAS,EAAE;QACb;MACF;MACAA,SAAS,GAAG,IAAI;MAChBE,OAAO,CAACpD,KAAK,CAAC,6CAA6C,CAAC;IAC9D,CAAC,CAAC;IAEFsC,UAAU,CAAC,MAAM;MACfW,YAAY,GAAG,IAAI;IACrB,CAAC,EAAEE,SAAS,CAAC;IAEb,eAAeE,wBAAwBA,CAAA,EAAG;MACxC,IAAI;QACF,IACE,CAACJ,YAAY,IACbN,gBAAgB,CAACW,SAAS,CAAC,CAAC,IAC5BX,gBAAgB,CAACY,WAAW,CAAC,CAAC,IAC9BL,SAAS,EACT;UACA;QACF;QAEA,MAAMP,gBAAgB,CAACa,OAAO,CAAC,CAAC;MAClC,CAAC,CAAC,OAAOT,CAAC,EAAE;QACVK,OAAO,CAACpD,KAAK,CAAC,8BAA8B,EAAE+C,CAAC,CAAC;QAChDG,SAAS,GAAG,IAAI;MAClB;IACF;;IAEA;IACA,MAAMO,MAAM,GAAGhD,IAAI,CAAC2B,gBAAgB,CAAC,yBAAyB,CAAiC;IAC/FqB,MAAM,CAAChB,OAAO,CAAEiB,KAAuB,IAAK;MAC1CA,KAAK,CAACZ,gBAAgB,CAAC,OAAO,EAAEO,wBAAwB,CAAC;MACzDK,KAAK,CAACZ,gBAAgB,CAAC,SAAS,EAAEO,wBAAwB,CAAC;IAC7D,CAAC,CAAC;EACJ,CAAC;;EAED;EACUM,YAAY,GAAIlD,IAAqB,IAAc;IAC3D;IACA,MAAMmD,WAAW,GAAGnD,IAAI,CAACoD,aAAa,CAAC,CAAC;IACxC,IAAI,CAACD,WAAW,EAAE;MAChBnD,IAAI,CAACqD,cAAc,CAAC,CAAC;IACvB;IACA,OAAOF,WAAW;EACpB,CAAC;EAEMZ,MAAM,GAAG,MAAAA,CAAOe,KAAY,EAAEtD,IAAqB,KAAK;IAC7DsD,KAAK,CAACC,cAAc,CAAC,CAAC;IACtB;;IAEA,IAAI,CAAC,IAAI,CAACL,YAAY,CAAClD,IAAI,CAAC,EAAE;MAC5B;IACF;IAEAA,IAAI,CAACwD,aAAa,CAAC,IAAI,CAAC7E,oBAAoB,CAAC,EAAEwD,YAAY,CAAC,UAAU,EAAE,UAAU,CAAC;IAEnF,MAAMsB,yBAAyB,GAAG,MAAAA,CAAA,KAAY;MAC5C,IAAI;QACF,IAAIC,KAAK,GAAG,EAAE;QACd,IAAI5E,wBAAwB,CAACC,YAAY,KAAK,YAAY,EAAE;UAC1D,MAAMmD,gBAAgB,GAAGlC,IAAI,CAACwD,aAAa,CAAC,mBAAmB,CAAC;UAEhEE,KAAK,GACH,CAAC,MACCxB,gBAAgB,EAGfa,OAAO,CAAC,CAAC,KAAK,EAAE;QACvB,CAAC,MAAM,IAAIjE,wBAAwB,CAACC,YAAY,KAAK,WAAW,EAAE;UAChE2E,KAAK,GAAG,MAAMC,UAAU,CAACZ,OAAO,CAACjE,wBAAwB,CAAC2C,gBAAgB,EAAE;YAC1EmC,MAAM,EAAE;UACV,CAAC,CAAC;QACJ;QAEA,MAAMC,QAAQ,GAAG,IAAIC,QAAQ,CAAC9D,IAAI,CAAC;QACnC;QACA,MAAM+D,UAAU,GAAGC,MAAM,CAACC,WAAW,CAACJ,QAAQ,CAAC;QAE/C,MAAMK,QAAQ,GAAI,MAAMC,KAAK,CAACnE,IAAI,CAAC4D,MAAM,EAAE;UACzCQ,IAAI,EAAE3D,IAAI,CAAC4D,SAAS,CAACN,UAAU,CAAC;UAChCO,OAAO,EAAE;YACP,kBAAkB,EAAEZ,KAAK;YACzB,cAAc,EAAE;UAClB,CAAC;UACDa,MAAM,EAAE;QACV,CAAC,CAAc;QACf,MAAMC,YAAY,GAAGN,QAAQ,CAACO,MAAM;QACpC,MAAM7E,IAAI,GAAG,MAAMsE,QAAQ,CAACQ,IAAI,CAAC,CAAC;QAClC1E,IAAI,CAACwD,aAAa,CAAC,IAAI,CAAC7E,oBAAoB,CAAC,EAAEgG,eAAe,CAAC,UAAU,CAAC;QAE1E,IAAIH,YAAY,KAAK,GAAG,EAAE;UACxBxE,IAAI,CAAC4E,KAAK,CAAC,CAAC;UACZ;UACA1D,QAAQ,CAAC2D,aAAa,CACpB,IAAIC,WAAW,CAAC1G,8CAAM,CAACC,oBAAoB,EAAE;YAAE0G,MAAM,EAAE;cAAEnF,IAAI;cAAEI,IAAI;cAAE+D;YAAW;UAAE,CAAC,CACrF,CAAC;UACD,IAAI,CAACiB,QAAQ,CAAC1B,KAAK,EAAEtD,IAAI,EAAE+D,UAAU,EAAEnE,IAAI,CAAC;QAC9C,CAAC,MAAM;UACL+C,OAAO,CAACpD,KAAK,CAAC,QAAQ,EAAEK,IAAI,CAAC;UAC7BsB,QAAQ,CAAC2D,aAAa,CACpB,IAAIC,WAAW,CAAC1G,8CAAM,CAACE,uBAAuB,EAAE;YAAEyG,MAAM,EAAE;cAAEnF,IAAI;cAAEI;YAAK;UAAE,CAAC,CAC5E,CAAC;UACD,IAAI,CAACiF,OAAO,CAAC3B,KAAK,EAAEtD,IAAI,EAAEJ,IAAI,CAAC;QACjC;MACF,CAAC,CAAC,OAAO0C,CAAU,EAAE;QACnB,MAAM/C,KAAK,GAAG+C,CAAU;QAExBpB,QAAQ,CAAC2D,aAAa,CACpB,IAAIC,WAAW,CAAC1G,8CAAM,CAACE,uBAAuB,EAAE;UAAEyG,MAAM,EAAE;YAAExF,KAAK;YAAES;UAAK;QAAE,CAAC,CAC7E,CAAC;QACD,IAAI,CAACiF,OAAO,CAAC3B,KAAK,EAAEtD,IAAI,EAAET,KAAK,CAAC;MAClC;IACF,CAAC;IAED,IAAI;MACF,IAAIT,wBAAwB,CAACC,YAAY,KAAK,WAAW,EAAE;QACzD,MAAM4E,UAAU,CAACuB,KAAK,CAACzB,yBAAyB,CAAC;MACnD,CAAC,MAAM;QACL,MAAMA,yBAAyB,CAAC,CAAC;MACnC;IACF,CAAC,CAAC,OAAOnB,CAAC,EAAE;MACVK,OAAO,CAACpD,KAAK,CAAC+C,CAAC,CAAC;IAClB;EACF,CAAC;AACH;;;;;;;;;;;;;;;;AClVsC;AACQ;AA0B/B,MAAM+C,QAAQ,CAAC;EAE5BzG,WAAWA,CAAA,EAAG;IACZ,IAAI,CAACuG,MAAM,GAAG,IAAIA,uDAAM,CAAC,IAAI,CAAC;IAC9B,IAAI,CAACA,MAAM,CAACG,SAAS,CAAC,IAAIF,2DAAU,CAAC,IAAI,CAAC,CAAC;EAC7C;EAEOG,MAAMA,CAAA,EAA2C;IACtD,MAAMC,aAAa,GAAG;MACpBC,gBAAgB,EAAE,KAAK;MACvBC,oBAAoB,EAAE,KAAK;MAC3BC,SAAS,EAAE,KAAK;MAChBC,MAAM,EAAE,IAAI;MACZC,OAAO,EAAE;QACPC,MAAM,EAAE;UACNC,iBAAiB,EAAE,CAAC,CAAC;UACrBC,QAAQ,EAAE,CAAC,CAAC;UACZrG,IAAI,EAAE;QACR;MACF,CAAC;MAEDsG,gBAAgB,EAAE;IACpB,CAAC;IACD,IAAI,OAAOC,MAAM,CAACpH,wBAAwB,KAAK,WAAW,EAAE;MAC1D;MACA,KAAK,MAAMqH,GAAG,IAAID,MAAM,CAACpH,wBAAwB,EAAE;QACjD,MAAMsH,QAAQ,GAAGD,GAAmD;QACpE,IAAID,MAAM,CAACpH,wBAAwB,CAACsH,QAAQ,CAAC,KAAK,MAAM,EAAE;UACvDF,MAAM,CAACpH,wBAAwB,CAACsH,QAAQ,CAAC,GAA0B,IAAI;QAC1E,CAAC,MAAM,IAAIF,MAAM,CAACpH,wBAAwB,CAACsH,QAAQ,CAAC,KAAK,OAAO,EAAE;UAC/DF,MAAM,CAACpH,wBAAwB,CAACsH,QAAQ,CAAC,GAA0B,KAAK;QAC3E;MACF;MAEA,OAAO;QAAE,GAAGZ,aAAa;QAAE,GAAGU,MAAM,CAACpH;MAAyB,CAAC;IACjE;IACA,OAAO0G,aAAa;EACtB;AACF;;;;;;;;;;;;;;;;ACnEqC;AAGQ;AAE9B,MAAML,MAAM,CAAC;EAClBmB,OAAO,GAAmB,EAAE;EAGpC1H,WAAWA,CAAC2H,QAAkB,EAAE;IAC9B,IAAI,CAACA,QAAQ,GAAGA,QAAQ;IAExB,MAAMC,sBAAsB,GAAGD,QAAQ,CAAChB,MAAM,CAAC,CAAC,CAACM,OAAO,EAAEC,MAAM,EAAEC,iBAAiB;IACnF,IAAI,CAACU,SAAS,GAAG,IAAIJ,0DAAS,CAC5B,IAAI,EACJG,sBAAsB,EAAEE,eAAe,IAAIzI,kDAAS,CAACC,0BAA0B,EAC/EsI,sBAAsB,EAAEG,uBAAuB,IAAI1I,kDAAS,CAACE,4BAC/D,CAAC;EACH;EAEOmH,SAASA,CAACsB,MAAoB,EAAE;IACrC,IAAI,CAACN,OAAO,CAACO,IAAI,CAACD,MAAM,CAAC;EAC3B;EAEQE,eAAeA,CAAA,EAAG;IACxB,MAAMhB,MAAM,GAAG,IAAI,CAACS,QAAQ,CAAChB,MAAM,CAAC,CAAC,CAACM,OAAO,CAACC,MAAM;IAEpD,MAAMiB,gBAAgB,GAAGjB,MAAM,EAAEnG,IAAI,IAAI,SAAS;IAElD,MAAMqH,YAAY,GAAG,IAAI,CAACV,OAAO,CAACW,MAAM,CAAEL,MAAM,IAAKA,MAAM,CAACM,OAAO,CAAC,CAAC,KAAKH,gBAAgB,CAAC,CAAC,CAAC,CAAC;IAC9F,IAAI,CAACC,YAAY,EAAE;MACjB,MAAM,IAAIG,KAAK,CAAC,iBAAiBJ,gBAAgB,YAAY,CAAC;IAChE;IACA,OAAOC,YAAY;EACrB;EAEA,MAAalB,MAAMA,CAACsB,KAAa,EAAE;IACjC,OAAO,IAAI,CAACN,eAAe,CAAC,CAAC,CAAChB,MAAM,CAACsB,KAAK,CAAC;EAC7C;EAEA,MAAaC,aAAaA,CAACC,MAAmB,EAAEC,OAAgB,EAAE;IAChE,IAAI,CAACT,eAAe,CAAC,CAAC,CAACO,aAAa,CAACC,MAAM,EAAEC,OAAO,CAAC;EACvD;EAEOC,YAAYA,CAAA,EAAG;IACpB,OAAO,IAAI,CAACf,SAAS;EACvB;AACF;;;;;;;;;;;;;;;;AC/CkE;AAClC;AAMjB,MAAMrB,UAAU,CAAyB;EAEtDxG,WAAWA,CAAC2H,QAAkB,EAAE;IAC9B,IAAI,CAACA,QAAQ,GAAGA,QAAQ;EAC1B;EAEOW,OAAOA,CAAA,EAAG;IACf,OAAO,SAAS;EAClB;EAEQS,IAAI,GAA8B,IAAI;EAEtCC,UAAU,GAAmB,EAAE;EAC/BC,WAAW,GAAmC,IAAI;EAElDC,YAAY,GAAG;IACrBC,QAAQ,EAAE,GAAG;IACb;IACAC,cAAc,EAAE,IAAI;IACpB;;IAEAC,eAAe,EAAE,KAAK;IACtB;IACA;IACAC,cAAc,EAAE,IAAI;IACpBC,YAAY,EAAE,IAAI;IAElBC,IAAI,EAAE,CAAC,OAAO,EAAE,SAAS,EAAE,SAAS,EAAE,UAAU,CAAC;IACjDC,UAAU,EAAE,IAAI;IAChB;IACA;IACAC,SAAS,EAAE,IAAI;IAEfC,iBAAiB,EAAE;EACrB,CAAC;EAED,MAAazC,MAAMA,CAACsB,KAAa,EAAuC;IACtE,MAAMxB,MAAM,GAAG,IAAI,CAACW,QAAQ,CAAChB,MAAM,CAAC,CAAC,CAACK,MAAM,IAAI,IAAI;IACpD,MAAMH,gBAAgB,GAAG,IAAI,CAACc,QAAQ,CAAChB,MAAM,CAAC,CAAC,CAACE,gBAAgB,IAAI,KAAK;IACzE,MAAMkC,IAAI,GAAG,MAAM,IAAI,CAACa,OAAO,CAAC,CAAC;IACjC,MAAMC,aAAyB,GAAG;MAChCC,IAAI,EAAE,CAAC;QAAEC,GAAG,EAAE,CAAC;UAAEC,KAAK,EAAExB;QAAM,CAAC,EAAE;UAAEyB,OAAO,EAAEzB;QAAM,CAAC,EAAE;UAAE0B,OAAO,EAAE1B;QAAM,CAAC;MAAE,CAAC;IAC5E,CAAC;IACD,IAAIxB,MAAM,IAAIH,gBAAgB,EAAE;MAC9BgD,aAAa,CAACC,IAAI,EAAE7B,IAAI,CAAC;QAAEkC,QAAQ,EAAE,IAAInD,MAAM;MAAG,CAAC,CAAC;IACtD;IAEA,MAAM2B,OAAO,GAAGI,IAAI,CAAC7B,MAAM,CAAC2C,aAAa,CAAC;IAC1C,OAAOlB,OAAO;EAChB;EAEQyB,UAAUA,CAAA,EAAG;IACnB,MAAMzD,MAAM,GAAG,IAAI,CAACgB,QAAQ,CAAChB,MAAM,CAAC,CAAC,CAACM,OAAO,CAACC,MAAM,EAAEE,QAAQ,IAAI,CAAC,CAAC;IACpE;IACAhC,MAAM,CAACoE,IAAI,CAAC7C,MAAM,CAAC,CAACvD,OAAO,CAAEmE,GAAG,IAAK;MACnC,IAAIA,GAAG,CAAC8C,UAAU,CAAC,OAAO,CAAC,EAAE;QAC3B,MAAMC,MAAM,GAAG/C,GAAG,CAACgD,OAAO,CAAC,OAAO,EAAE,EAAE,CAAmC;QACzE,MAAMC,KAAK,GAAG7D,MAAM,CAACY,GAAG,CAAwB;QAC/C,IAAI,CAAC2B,YAAY,CAACoB,MAAM,CAAC,GAAoBE,KAAK;MACrD;IACF,CAAC,CAAC;IAEF,OAAO,IAAI,CAACtB,YAAY;EAC1B;EAEA,MAAaU,OAAOA,CAAA,EAAgC;IAClD,MAAM,IAAI,CAACa,cAAc,CAAC,CAAC;IAC3B,IAAI,CAAC1B,IAAI,GAAG,IAAIF,+CAAI,CAClB,IAAI,CAACG,UAAU,EACf,IAAI,CAACE,YAAY,EACjB,IAAI,CAACD,WACP,CAAC;IACD,OAAO,IAAI,CAACF,IAAI;EAClB;EAEA,MAAa0B,cAAcA,CAACC,KAAK,GAAG,KAAK,EAAE;IACzC,IAAI,IAAI,CAACzB,WAAW,IAAI,CAACyB,KAAK,EAAE;MAC9B,OAAO,IAAI,CAACzB,WAAW;IACzB;IACA,MAAM3D,QAAQ,GAAG,MAAMC,KAAK,CAAC,IAAI,CAACoC,QAAQ,CAAChB,MAAM,CAAC,CAAC,CAACU,gBAAgB,CAAC;IACrE,IAAI,CAAC2B,UAAU,GAAG,MAAM1D,QAAQ,CAACQ,IAAI,CAAC,CAAC;IAEvC,IAAI,CAACsE,UAAU,CAAC,CAAC;IACjB,IAAI,CAACnB,WAAW,GAAG,MAAMJ,+CAAI,CAAC8B,WAAW,CACvC,IAAI,CAACzB,YAAY,CAACM,IAAI,EACtB,IAAI,CAACR,UACP,CAAC;IAED,OAAO,IAAI,CAACC,WAAW;EACzB;EAEOR,aAAaA,CAACC,MAAmB,EAAEC,OAAmC,EAAE;IAC7E,MAAMiC,QAAQ,GAAGtI,QAAQ,CAACuI,cAAc,CAAC,oCAAoC,CAAC,EAAEC,SAAS;IACzF,IAAI,CAACF,QAAQ,EAAE;MACb;IACF;IAEA,MAAMG,QAAQ,GAAGjC,gDAAQ;IACzB,MAAMkC,IAAI,GAAGrC,OAAO,CACjBsC,GAAG,CAAEC,MAAM,IAAK;MACf,OAAO,MAAM,GAAGH,QAAQ,CAACI,MAAM,CAACP,QAAQ,EAAEM,MAAM,CAACE,IAAI,CAAC,GAAG,OAAO;IAClE,CAAC,CAAC,CACDC,IAAI,CAAC,EAAE,CAAC;IAEX3C,MAAM,CAACoC,SAAS,GAAG,MAAM,GAAGE,IAAI,GAAG,OAAO;EAC5C;AACF;;;;;;;;;;;;;;;ACjHqC;AAGrC;AACA;AACA;AACA;AACA;AACA;AACA;AACe,MAAMvD,SAAS,CAAC;EAGrB6D,QAAQ,GAA+B,IAAI;EAGnDtL,WAAWA,CACToI,YAAoB,EACpBtI,QAAgB,GAAGT,kDAAS,CAACC,0BAA0B,EACvDiM,qBAA6B,GAAGlM,kDAAS,CAACE,4BAA4B,EACtE;IACA,IAAI,CAACO,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACyL,qBAAqB,GAAGA,qBAAqB;IAClD,IAAI,CAACnD,YAAY,GAAGA,YAAY;IAChC9F,QAAQ,CAACmB,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAAC+H,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC;EAC9E;EAEQD,aAAa,GAAGA,CAAA,KAAM;IAC5B,IAAI,CAACF,QAAQ,GAAGhJ,QAAQ,CAACS,gBAAgB,CAAC,IAAI,CAACjD,QAAQ,CAAC;IACxD;;IAEA,IAAI,CAACQ,UAAU,CAAC,CAAC;EACnB,CAAC;EAEMoL,WAAW,GAAGA,CAAA,KAA0B;IAC7C,IAAI,CAAC,IAAI,CAACJ,QAAQ,EAAE;MAClB,OAAO,EAAE;IACX;IACA;IACA,OAAOK,KAAK,CAACC,IAAI,CAAC,IAAI,CAACN,QAAQ,CAAC,CAACjD,MAAM,CACpCwD,OAAO,IAAK,CAACA,OAAO,CAACC,OAAO,CAAC,aAAa,CAC7C,CAAC;EACH,CAAC;EAEMxL,UAAU,GAAGA,CAAA,KAAM;IACxB,MAAMgL,QAAQ,GAAG,IAAI,CAACI,WAAW,CAAC,CAAC;IACnCJ,QAAQ,IACNA,QAAQ,CAAClI,OAAO,CAAEyI,OAAO,IAAK;MAC5B;;MAEA;MACA,IAAIA,OAAO,CAACxI,YAAY,CAAC,MAAM,CAAC,KAAK,GAAG,EAAE;QACxCwI,OAAO,CAACtI,YAAY,CAAC,MAAM,EAAE,GAAG,CAAC;MACnC;;MAEA;MACA,MAAMwI,YAAY,GAAG,IAAIC,eAAe,CAAC1E,MAAM,CAAC2E,QAAQ,CAAC/E,MAAM,CAAC;MAChE,MAAMsB,KAAK,GAAGuD,YAAY,CAACG,GAAG,CAAC,GAAG,CAAC;MAEnCL,OAAO,CAACpI,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC0I,QAAQ,CAAC;MAChD,IAAI3D,KAAK,EAAE;QACTqD,OAAO,CAACtI,YAAY,CAAC,OAAO,EAAEiF,KAAK,CAAC;QACpCqD,OAAO,CAACrB,KAAK,GAAGhC,KAAK;QACrB,MAAM9D,KAAK,GAAG,IAAI0H,KAAK,CAAC,OAAO,CAAC;QAChCP,OAAO,CAAC5F,aAAa,CAACvB,KAAK,CAAC;MAC9B;MACA;MACAmH,OAAO,CAACC,OAAO,CAAC,MAAM,CAAC,EAAErI,gBAAgB,CAAC,QAAQ,EAAGiB,KAAK,IAAK;QAC7DA,KAAK,CAACC,cAAc,CAAC,CAAC;MACxB,CAAC,CAAC;MAEF2C,MAAM,CAAC7D,gBAAgB,CAAC,UAAU,EAAE,IAAI,CAAC4I,UAAU,CAAC;IACtD,CAAC,CAAC;EACN,CAAC;EAEDA,UAAU,GAAIC,MAAqB,IAAK;IACtC,MAAMP,YAAY,GAAG,IAAIC,eAAe,CAAC1E,MAAM,CAAC2E,QAAQ,CAAC/E,MAAM,CAAC;IAChE,MAAMsB,KAAK,GAAGuD,YAAY,CAACG,GAAG,CAAC,GAAG,CAAC;IACnC,IAAI1D,KAAK,EAAE;MACT,IAAI,CAACkD,WAAW,CAAC,CAAC,CAACtI,OAAO,CAAEyI,OAAO,IAAK;QACtCA,OAAO,CAACtI,YAAY,CAAC,OAAO,EAAEiF,KAAK,CAAC;QACpCqD,OAAO,CAACrB,KAAK,GAAGhC,KAAK;QACrB,MAAM9D,KAAK,GAAG,IAAI0H,KAAK,CAAC,OAAO,CAAC;QAChC;;QAEAP,OAAO,CAACU,IAAI,CAAC,CAAC;QAEdV,OAAO,CAAC5F,aAAa,CAACvB,KAAK,CAAC;MAC9B,CAAC,CAAC;IACJ;EACF,CAAC;EAEDyH,QAAQ,GAAG,MAAOzH,KAAY,IAAK;IACjC,MAAMgE,MAAM,GAAGhE,KAAK,CAACgE,MAA0B;IAC/C,IAAIhE,KAAK,CAAC8H,SAAS,EAAE;MACnB;MACA,MAAMT,YAAY,GAAG,IAAIC,eAAe,CAAC1E,MAAM,CAAC2E,QAAQ,CAAC/E,MAAM,CAAC;MAChE6E,YAAY,CAACU,GAAG,CAAC,GAAG,EAAE/D,MAAM,CAAC8B,KAAK,CAAC;MACnClD,MAAM,CAACoF,OAAO,CAACC,SAAS,CACtB;QAAEC,CAAC,EAAElE,MAAM,CAAC8B;MAAM,CAAC,EACnB,EAAE,EACF,GAAGlD,MAAM,CAAC2E,QAAQ,CAACY,QAAQ,IAAId,YAAY,CAACe,QAAQ,CAAC,CAAC,EACxD,CAAC;IACH;IAEA,IAAIC,YAAY,GACdrE,MAAM,CAACoD,OAAO,CAAC,QAAQ,CAAC,EAAElH,aAAa,CAAC,IAAI,CAAC2G,qBAAqB,CAAC,IACnE7C,MAAM,CAACoD,OAAO,CAAC,MAAM,CAAC,EAAElH,aAAa,CAAC,IAAI,CAAC2G,qBAAqB,CAAC,IACjE7C,MAAM,CAACoD,OAAO,CAAC,KAAK,CAAC,EAAElH,aAAa,CAAC,IAAI,CAAC2G,qBAAqB,CAAC;IAElE,IAAI,CAACwB,YAAY,EAAE;MACjB;MACAA,YAAY,GAAGzK,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;MAC5CwK,YAAY,CAACC,SAAS,GAAG,4BAA4B;MACrD,MAAMC,YAAY,GAChBvE,MAAM,CAACoD,OAAO,CAAC,QAAQ,CAAC,IAAIpD,MAAM,CAACoD,OAAO,CAAC,MAAM,CAAC,IAAIpD,MAAM,CAACoD,OAAO,CAAC,KAAK,CAAC;MAC7E,IAAImB,YAAY,EAAE;QAChBA,YAAY,CAACrK,WAAW,CAACmK,YAAY,CAAC;MACxC,CAAC,MAAM;QACLhJ,OAAO,CAACpD,KAAK,CAAC,mDAAmD,CAAC;QAClE;MACF;IACF;IAEA,MAAMgI,OAAO,GAAG,MAAM,IAAI,CAACP,YAAY,CAAClB,MAAM,CAACwB,MAAM,CAAC8B,KAAK,CAAC;IAC5D,IAAI,CAACpC,YAAY,CAACK,aAAa,CAACsE,YAAY,EAAiBpE,OAAO,CAAC;EACvE,CAAC;AACH;;;;;;;;;;AC/HA;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,2BAA2B,IAAI;;AAE/B;AACA,mCAAmC,IAAI;;AAEvC,kDAAkD,MAAM;;AAExD;AACA,+BAA+B,IAAI;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,2BAA2B;;AAEpD;AACA,kBAAkB,wBAAwB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,eAAe;AACf,aAAa;AACb,YAAY;AACZ;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,iEAAiE;AACrE;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,iEAAiE;AACrE;AACA,UAAU,gBAAgB;AAC1B,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,kBAAkB,gBAAgB;AAClC,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,yBAAyB,YAAY;AACrC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,YAAY,kCAAkC;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;;AAEA,2BAA2B,+BAA+B;AAC1D,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,SAAS;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,kCAAkC;;AAE9C;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,UAAU;AACnD;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C,UAAU;AACzD;AACA,gBAAgB,0BAA0B;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA,iCAAiC,cAAc,IAAI;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,8BAA8B,kBAAkB;AAChD;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,YAAY,iBAAiB;;AAE7B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA,YAAY,MAAM;;AAElB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA,GAAG;AACH;;AAEA;AACA,gCAAgC;AAChC,qBAAqB;;AAErB;AACA;AACA;AACA,MAAM,EAED;;AAEL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,aAAa,IAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,iBAAiB;;AAE7C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,YAAY,UAAU;AACtB;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA,cAAc,0BAA0B;;AAExC;AACA;AACA;AACA;AACA,sBAAsB,mCAAmC;AACzD,SAAS;AACT;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,gBAAgB,kBAAkB;;AAElC;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,gCAAgC,SAAS;AACzC;AACA,WAAW;AACX;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,YAAY,gBAAgB;AAC5B;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;;AAEL;AACA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA,gBAAgB,0BAA0B;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,MAAM;AACN,cAAc,mBAAmB;;AAEjC,cAAc,0BAA0B;;AAExC;AACA,uBAAuB,wCAAwC;AAC/D;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;ACjvD3B;AACA,8BAA8B,WAAW;AACzC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb,YAAY;AACZ,YAAY;AACZ,cAAc;AACd,aAAa;AACb,cAAc;AACd,cAAc;AACd,cAAc;AACd;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB,gBAAgB,MAAM;AAC/C,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;;AAEzB;AACA,sBAAsB,OAAO;AAC7B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kDAAkD,iBAAiB;AACnE;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,oBAAoB;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM,uCAAuC;AAC7C;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,eAAe;AAC5D;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,eAAe;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,WAAW,UAAU,SAAS,KAAK,oBAAoB;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,eAAe;AAC5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iEAAe,QAAQ,EAAC;;;;;;;UC3vBxB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;ACNA;AACA;AACA;AACwC;AACN;AACE;;AAEpC;AACArB,MAAM,CAAC4F,kBAAkB,GAAG,IAAIzG,iDAAQ,CAAC,CAAC;;AAE1C;AACA;AACA;AACA;AACA;AACAa,MAAM,CAAC6F,yBAAyB,GAAG;EACjCvN,QAAQ;EACRP,SAASA,oDAAAA;AACX,CAAC,C","sources":["webpack://static-snap/./src/frontend/app/src/constants.ts","webpack://static-snap/./src/frontend/app/src/form/form-base.ts","webpack://static-snap/./src/frontend/app/src/frontend.ts","webpack://static-snap/./src/frontend/app/src/modules/search.ts","webpack://static-snap/./src/frontend/app/src/search/fuse-search.ts","webpack://static-snap/./src/frontend/app/src/search/search-box.ts","webpack://static-snap/external window [\"wp\",\"i18n\"]","webpack://static-snap/./node_modules/fuse.js/dist/fuse.mjs","webpack://static-snap/./node_modules/mustache/mustache.mjs","webpack://static-snap/webpack/bootstrap","webpack://static-snap/webpack/runtime/compat get default export","webpack://static-snap/webpack/runtime/define property getters","webpack://static-snap/webpack/runtime/hasOwnProperty shorthand","webpack://static-snap/webpack/runtime/make namespace object","webpack://static-snap/./src/frontend/app/src/start.ts"],"sourcesContent":["const Constants = {\n  defaultSearchInputSelector: 'input[name=\"s\"], input[name=\"q\"]',\n  defaultSearchResultsSelector: '.static-snap-search-results',\n};\n\nexport const Events = {\n  FORM_SUBMITTED_EVENT: '@staticsnap/form/submitted',\n  FORM_SUBMIT_ERROR_EVENT: '@staticsnap/form/submit-error',\n};\n\nexport default Constants;\n","import ApiResponseInterface from '@staticsnap/frontend/src/interfaces/api-response.interface';\nimport { __ } from '@wordpress/i18n';\n\nimport { Events } from '../constants';\nimport FormSubmitResponseInterface, {\n  WebsiteFormSettings,\n} from '../interfaces/form-submit-response.interface';\n\n// jQuery is available in the global scope\ndeclare const jQuery: any; // eslint-disable-line @typescript-eslint/no-explicit-any\ndeclare const grecaptcha: any; // eslint-disable-line @typescript-eslint/no-explicit-any\ndeclare const StaticSnapFrontendConfig: {\n  captcha_type: string;\n  captcha_site_key: string;\n};\n\nexport type FormBaseNoticeMessageSettings = {\n  type: 'message' | 'redirect';\n  success_message: string;\n  error_message: string;\n  required_field_message: string;\n  invalid_message: string;\n  redirect_url?: string;\n};\n\nexport type FormBaseGetNoticeMessageType = 'success' | 'error' | 'field_error' | 'invalid_error';\n\nexport default abstract class FormBase {\n  protected forms: NodeListOf<HTMLFormElement> | null = null;\n  protected selector: string = '[data-static-snap-type=\"form\"]';\n  protected submitButtonSelector: string = '[type=\"submit\"]';\n\n  // constructor\n  constructor(selector?: string) {\n    if (selector) {\n      this.selector = selector;\n    }\n\n    if (['powcaptcha', 'recaptcha'].includes(StaticSnapFrontendConfig.captcha_type)) {\n      if (StaticSnapFrontendConfig.captcha_type === 'recaptcha') {\n        this.loadGoogleRecaptcha();\n      } else if (StaticSnapFrontendConfig.captcha_type === 'powcaptcha') {\n        this.loadPowCaptcha();\n      }\n    }\n\n    this.bindEvents();\n    //this.bindPluginsEvents();\n  }\n  /**\n   *\n   * This method is called when the form is submitted.\n   * @param e          - The event object.\n   * @param form       - The form element.\n   * @param submitData - The data that will be sent to the server.\n   * @return void\n   * @example\n   * onSubmit(e: Event, form: HTMLFormElement, submitData: any): void \\{\n   *  console.log('Form submitted', e, form, submitData);\n   * \\}\n   * @example\n   */\n  protected abstract onSubmit(\n    e: Event,\n    form: HTMLFormElement,\n    submitData: any,\n    responseData: ApiResponseInterface<FormSubmitResponseInterface>\n  ): void;\n\n  /**\n   * This method is called when an error occurs during form submission.\n   * @param e     - The event object.\n   * @param form  - The form element.\n   * @param error - The error object.\n   */\n  protected abstract onError(e: Event, form: HTMLFormElement, error: any): void;\n\n  /**\n   * Get form settings\n   * @param responseData - The response data from the server.\n   * @return WebsiteFormSettings\n   */\n  protected getFormSettings = (\n    responseData: ApiResponseInterface<FormSubmitResponseInterface>\n  ): WebsiteFormSettings => {\n    const defaultSettings = {\n      messages: {\n        error: __('An error occurred while submitting the form', 'static-snap'),\n        invalid: __('Please enter a valid value.', 'static-snap'),\n        required: __('This field is required.', 'static-snap'),\n        success: __('The form was sent successfully.', 'static-snap'),\n      },\n    };\n    if (!responseData.type || responseData.type !== 'item') {\n      return defaultSettings;\n    }\n\n    // merge default settings with response data\n    return { ...defaultSettings, ...responseData.data.websiteForm?.website_form_settings };\n  };\n\n  /**\n   * Get notice message settings\n   * @param form - The form element.\n   */\n  protected getNoticeMessageSettings = (form: HTMLFormElement): FormBaseNoticeMessageSettings => {\n    const defaultMessageSettings: FormBaseNoticeMessageSettings = {\n      error_message: __('An error occurred while submitting the form', 'static-snap'),\n      invalid_message: __('Please enter a valid value.', 'static-snap'),\n      required_field_message: __('This field is required.', 'static-snap'),\n      success_message: __('The form was sent successfully.', 'static-snap'),\n      type: 'message',\n    };\n    const messageSettings = form.dataset?.staticSnapFormNoticeSettings;\n    if (!messageSettings) {\n      return defaultMessageSettings;\n    }\n\n    try {\n      return { ...defaultMessageSettings, ...JSON.parse(messageSettings) };\n    } catch (_e) {\n      return defaultMessageSettings;\n    }\n  };\n\n  protected getNoticeMessageOrRedirect = (\n    form: HTMLFormElement,\n    type: FormBaseGetNoticeMessageType\n  ): string => {\n    const messageSettings = this.getNoticeMessageSettings(form);\n\n    // if redirect type, we don't need to show any message. We will redirect to the URL\n    if (messageSettings.type === 'redirect' && type === 'success' && messageSettings.redirect_url) {\n      //window.location.href = messageSettings.redirect_url;\n    }\n\n    const messageMap: Record<FormBaseGetNoticeMessageType, string> = {\n      error: messageSettings.error_message,\n      field_error: messageSettings.required_field_message,\n      invalid_error: messageSettings.invalid_message,\n      success: messageSettings.success_message,\n    };\n\n    return messageMap[type] || '';\n  };\n\n  protected loadPowCaptcha = () => {\n    const script = document.createElement('script');\n    script.src = 'https://js.powcaptcha.com/widget.js';\n    script.async = true;\n    script.defer = true;\n    script.type = 'module';\n    document.head.appendChild(script);\n  };\n\n  protected loadGoogleRecaptcha = () => {\n    const script = document.createElement('script');\n    script.src = `https://www.google.com/recaptcha/api.js?render=${StaticSnapFrontendConfig.captcha_site_key}`;\n    script.async = true;\n    script.defer = true;\n    document.head.appendChild(script);\n  };\n\n  public getForms = (): NodeListOf<HTMLFormElement> => {\n    // get all static_snap_type=\"form\" elements\n    return document.querySelectorAll(this.selector) as NodeListOf<HTMLFormElement>;\n  };\n\n  /**\n   * Remove form submit events.\n   * @param form - The form element from which to unbind submit events.\n   */\n  public unbindSubmitEvents = (form: HTMLFormElement): void => {\n    setTimeout(() => {\n      jQuery(form).off('submit');\n    }, 500);\n  };\n\n  /**\n   * Clone forms to remove events\n   */\n  public bindEvents = () => {\n    this.forms = this.getForms();\n\n    this.forms.forEach((form) => {\n      // check if form is already initialized\n      if (form.getAttribute('data-static-snap-initialized') === 'true') {\n        return;\n      }\n      // remove all jQuery submit events\n      this.unbindSubmitEvents(form);\n      // add a new submit event\n\n      // if is powcaptcha, we need to add the powcaptcha widget\n      if (StaticSnapFrontendConfig.captcha_type === 'powcaptcha') {\n        const powcaptchaWidget = document.createElement('powcaptcha-widget');\n        powcaptchaWidget.setAttribute('data-app-id', StaticSnapFrontendConfig.captcha_site_key);\n        powcaptchaWidget.setAttribute('data-invisible', 'true');\n\n        form.appendChild(powcaptchaWidget);\n        this.bindPowCaptchaEvents(form, powcaptchaWidget);\n      }\n\n      form.addEventListener('submit', (e) => this.submit(e, form));\n      // mark form as initialized\n      form.setAttribute('data-static-snap-initialized', 'true');\n    });\n  };\n\n  protected bindPowCaptchaEvents = (form: HTMLFormElement, powcaptchaWidget: any) => {\n    let signalsReady = false;\n    let haveError = false;\n    const timeoutMs = 5000; // 5 seconds timeout to get signals\n\n    powcaptchaWidget.addEventListener('@powcaptcha/widget/error', function () {\n      if (haveError) {\n        return;\n      }\n      haveError = true;\n      console.error('Please check your PowCaptcha configuration.');\n    });\n\n    setTimeout(() => {\n      signalsReady = true;\n    }, timeoutMs);\n\n    async function resolveIfSignalsAreReady() {\n      try {\n        if (\n          !signalsReady ||\n          powcaptchaWidget.isLoading() ||\n          powcaptchaWidget.isValidated() ||\n          haveError\n        ) {\n          return;\n        }\n\n        await powcaptchaWidget.execute();\n      } catch (e) {\n        console.error('PowCaptcha execution failed:', e);\n        haveError = true;\n      }\n    }\n\n    // watch form fields\n    const fields = form.querySelectorAll('input, textarea, select') as NodeListOf<HTMLInputElement>;\n    fields.forEach((field: HTMLInputElement) => {\n      field.addEventListener('focus', resolveIfSignalsAreReady);\n      field.addEventListener('keydown', resolveIfSignalsAreReady);\n    });\n  };\n\n  // before submit\n  protected beforeSubmit = (form: HTMLFormElement): boolean => {\n    // trigger html form validation by default\n    const isFormValid = form.checkValidity();\n    if (!isFormValid) {\n      form.reportValidity();\n    }\n    return isFormValid;\n  };\n\n  public submit = async (event: Event, form: HTMLFormElement) => {\n    event.preventDefault();\n    // disable submit button\n\n    if (!this.beforeSubmit(form)) {\n      return;\n    }\n\n    form.querySelector(this.submitButtonSelector)?.setAttribute('disabled', 'disabled');\n\n    const submitFormDataWithCaptcha = async () => {\n      try {\n        let token = '';\n        if (StaticSnapFrontendConfig.captcha_type === 'powcaptcha') {\n          const powcaptchaWidget = form.querySelector('powcaptcha-widget');\n\n          token =\n            (await (\n              powcaptchaWidget as unknown as {\n                execute: () => Promise<string>;\n              }\n            )?.execute()) || '';\n        } else if (StaticSnapFrontendConfig.captcha_type === 'recaptcha') {\n          token = await grecaptcha.execute(StaticSnapFrontendConfig.captcha_site_key, {\n            action: 'submit',\n          });\n        }\n\n        const formData = new FormData(form);\n        // send form data to action URL as json\n        const submitData = Object.fromEntries(formData);\n\n        const response = (await fetch(form.action, {\n          body: JSON.stringify(submitData),\n          headers: {\n            'Captcha-Response': token,\n            'Content-Type': 'application/json',\n          },\n          method: 'POST',\n        })) as Response;\n        const responseCode = response.status;\n        const data = await response.json();\n        form.querySelector(this.submitButtonSelector)?.removeAttribute('disabled');\n\n        if (responseCode === 200) {\n          form.reset();\n          // emit event\n          document.dispatchEvent(\n            new CustomEvent(Events.FORM_SUBMITTED_EVENT, { detail: { data, form, submitData } })\n          );\n          this.onSubmit(event, form, submitData, data);\n        } else {\n          console.error('Error:', data);\n          document.dispatchEvent(\n            new CustomEvent(Events.FORM_SUBMIT_ERROR_EVENT, { detail: { data, form } })\n          );\n          this.onError(event, form, data);\n        }\n      } catch (e: unknown) {\n        const error = e as Error;\n\n        document.dispatchEvent(\n          new CustomEvent(Events.FORM_SUBMIT_ERROR_EVENT, { detail: { error, form } })\n        );\n        this.onError(event, form, error);\n      }\n    };\n\n    try {\n      if (StaticSnapFrontendConfig.captcha_type === 'recaptcha') {\n        await grecaptcha.ready(submitFormDataWithCaptcha);\n      } else {\n        await submitFormDataWithCaptcha();\n      }\n    } catch (e) {\n      console.error(e);\n    }\n  };\n}\n","import Constants from './constants';\nimport FormBase from './form/form-base';\nimport Search from './modules/search';\nimport FuseSearch from './search/fuse-search';\n\ndeclare global {\n  interface Window {\n    StaticSnapFrontendClasses: {\n      FormBase: typeof FormBase;\n      Constants: typeof Constants;\n    };\n    StaticSnapFrontendConfig: {\n      locale: string | null;\n      has_translations: boolean | string;\n      is_static: boolean | string;\n      is_admin_bar_showing: boolean | string;\n      search_index_url: string;\n      options: {\n        search: {\n          type: string;\n          frontend_settings: Record<string, string>;\n          settings: Record<string, unknown>;\n        };\n      };\n    };\n    StaticSnapFrontend: Frontend;\n  }\n}\n\nexport default class Frontend {\n  public Search: Search;\n  constructor() {\n    this.Search = new Search(this);\n    this.Search.addModule(new FuseSearch(this));\n  }\n\n  public config(): typeof window.StaticSnapFrontendConfig {\n    const defaultConfig = {\n      has_translations: false,\n      is_admin_bar_showing: false,\n      is_static: false,\n      locale: null,\n      options: {\n        search: {\n          frontend_settings: {},\n          settings: {},\n          type: 'fuse-js',\n        },\n      },\n\n      search_index_url: '/search.json',\n    };\n    if (typeof window.StaticSnapFrontendConfig !== 'undefined') {\n      // convert boolean strings to boolean\n      for (const key in window.StaticSnapFrontendConfig) {\n        const keyIndex = key as keyof typeof window.StaticSnapFrontendConfig;\n        if (window.StaticSnapFrontendConfig[keyIndex] === 'true') {\n          (window.StaticSnapFrontendConfig[keyIndex] as unknown as boolean) = true;\n        } else if (window.StaticSnapFrontendConfig[keyIndex] === 'false') {\n          (window.StaticSnapFrontendConfig[keyIndex] as unknown as boolean) = false;\n        }\n      }\n\n      return { ...defaultConfig, ...window.StaticSnapFrontendConfig };\n    }\n    return defaultConfig;\n  }\n}\n","import Constants from '../constants';\nimport Frontend from '../frontend';\nimport SearchModule from '../interfaces/search-module.interface';\nimport SearchBox from '../search/search-box';\n\nexport default class Search {\n  private modules: SearchModule[] = [];\n  private frontend: Frontend;\n  private searchBox: SearchBox;\n  constructor(frontend: Frontend) {\n    this.frontend = frontend;\n\n    const frontendSearchSettings = frontend.config().options?.search?.frontend_settings;\n    this.searchBox = new SearchBox(\n      this,\n      frontendSearchSettings?.search_selector || Constants.defaultSearchInputSelector,\n      frontendSearchSettings?.search_results_selector || Constants.defaultSearchResultsSelector\n    );\n  }\n\n  public addModule(module: SearchModule) {\n    this.modules.push(module);\n  }\n\n  private getSearchModule() {\n    const search = this.frontend.config().options.search;\n\n    const searchModuleType = search?.type || 'fuse-js';\n\n    const searchModule = this.modules.filter((module) => module.getType() === searchModuleType)[0];\n    if (!searchModule) {\n      throw new Error(`Search module ${searchModuleType} not found`);\n    }\n    return searchModule;\n  }\n\n  public async search(query: string) {\n    return this.getSearchModule().search(query);\n  }\n\n  public async renderResults(target: HTMLElement, results: unknown) {\n    this.getSearchModule().renderResults(target, results);\n  }\n\n  public getSearchBox() {\n    return this.searchBox;\n  }\n}\n","import Fuse, { FuseResult, FuseIndex, Expression } from 'fuse.js';\nimport Mustache from 'mustache';\n\nimport Frontend from '../frontend';\nimport DocumentType from '../interfaces/document.interface';\nimport SearchModule from '../interfaces/search-module.interface';\n\nexport default class FuseSearch implements SearchModule {\n  private frontend: Frontend;\n  constructor(frontend: Frontend) {\n    this.frontend = frontend;\n  }\n\n  public getType() {\n    return 'fuse-js';\n  }\n\n  private fuse: Fuse<DocumentType> | null = null;\n\n  private searchData: DocumentType[] = [];\n  private searchIndex: FuseIndex<DocumentType> | null = null;\n\n  private fuse_options = {\n    distance: 100,\n    // includeMatches: false,\n    findAllMatches: true,\n    // isCaseSensitive: false,\n\n    ignoreFieldNorm: false,\n    // this is the easiest way to get the search to work if you don't know about scoring theory\n    // read more at here: https://www.fusejs.io/concepts/scoring-theory.html\n    ignoreLocation: true,\n    includeScore: true,\n\n    keys: ['title', 'content', 'excerpt', 'language'],\n    shouldSort: true,\n    // minMatchCharLength: 1,\n    // location: 0,\n    threshold: 0.55,\n\n    useExtendedSearch: true,\n  };\n\n  public async search(query: string): Promise<FuseResult<DocumentType>[]> {\n    const locale = this.frontend.config().locale || null;\n    const has_translations = this.frontend.config().has_translations || false;\n    const fuse = await this.getFuse();\n    const extendedQuery: Expression = {\n      $and: [{ $or: [{ title: query }, { content: query }, { excerpt: query }] }],\n    };\n    if (locale && has_translations) {\n      extendedQuery.$and?.push({ language: `=${locale}` });\n    }\n\n    const results = fuse.search(extendedQuery);\n    return results;\n  }\n\n  private getOptions() {\n    const config = this.frontend.config().options.search?.settings || {};\n    // convert all fuse_* to fuse options\n    Object.keys(config).forEach((key) => {\n      if (key.startsWith('fuse_')) {\n        const option = key.replace('fuse_', '') as keyof typeof this.fuse_options;\n        const value = config[key as keyof typeof config];\n        (this.fuse_options[option] as typeof value) = value;\n      }\n    });\n\n    return this.fuse_options;\n  }\n\n  public async getFuse(): Promise<Fuse<DocumentType>> {\n    await this.getSearchIndex();\n    this.fuse = new Fuse<DocumentType>(\n      this.searchData,\n      this.fuse_options,\n      this.searchIndex as FuseIndex<DocumentType>\n    );\n    return this.fuse;\n  }\n\n  public async getSearchIndex(force = false) {\n    if (this.searchIndex && !force) {\n      return this.searchIndex;\n    }\n    const response = await fetch(this.frontend.config().search_index_url);\n    this.searchData = await response.json();\n\n    this.getOptions();\n    this.searchIndex = await Fuse.createIndex<DocumentType>(\n      this.fuse_options.keys,\n      this.searchData\n    );\n\n    return this.searchIndex;\n  }\n\n  public renderResults(target: HTMLElement, results: FuseResult<DocumentType>[]) {\n    const template = document.getElementById('static-snap-search-result-template')?.innerHTML;\n    if (!template) {\n      return;\n    }\n\n    const rendered = Mustache;\n    const html = results\n      .map((result) => {\n        return '<li>' + rendered.render(template, result.item) + '</li>';\n      })\n      .join('');\n\n    target.innerHTML = '<ol>' + html + '</ol>';\n  }\n}\n","import Constants from '../constants';\nimport { Search } from '../modules';\n\n/**\n * This class is responsible for handling the search input and displaying the search results.\n * It listens to the input event on the input element and calls the search method of the Search module.\n * It then renders the results in the searchResultsSelector element.\n * If the searchResultsSelector element is not found, it creates a new div element next to the input element.\n * The search results are rendered in this new div element.\n */\nexport default class SearchBox {\n  private selector: string;\n  private searchResultsSelector: string;\n  private elements: NodeListOf<Element> | null = null;\n  private searchModule: Search;\n\n  constructor(\n    searchModule: Search,\n    selector: string = Constants.defaultSearchInputSelector,\n    searchResultsSelector: string = Constants.defaultSearchResultsSelector\n  ) {\n    this.selector = selector;\n    this.searchResultsSelector = searchResultsSelector;\n    this.searchModule = searchModule;\n    document.addEventListener('DOMContentLoaded', this.initDomEvents.bind(this));\n  }\n\n  private initDomEvents = () => {\n    this.elements = document.querySelectorAll(this.selector);\n    // on press back button, get the value of q and search\n\n    this.bindEvents();\n  };\n\n  public getElements = (): HTMLInputElement[] => {\n    if (!this.elements) {\n      return [];\n    }\n    // filter elements that are in wpadminbar\n    return Array.from(this.elements).filter(\n      (element) => !element.closest('#wpadminbar')\n    ) as HTMLInputElement[];\n  };\n\n  public bindEvents = () => {\n    const elements = this.getElements();\n    elements &&\n      elements.forEach((element) => {\n        // ignore the search on wpadminbar\n\n        // if element name=s change to q\n        if (element.getAttribute('name') === 's') {\n          element.setAttribute('name', 'q');\n        }\n\n        // if have a searchParams in the url, get the value of q and search\n        const searchParams = new URLSearchParams(window.location.search);\n        const query = searchParams.get('q');\n\n        element.addEventListener('input', this.onSearch);\n        if (query) {\n          element.setAttribute('value', query);\n          element.value = query;\n          const event = new Event('input');\n          element.dispatchEvent(event);\n        }\n        // disable submit on form\n        element.closest('form')?.addEventListener('submit', (event) => {\n          event.preventDefault();\n        });\n\n        window.addEventListener('popstate', this.onPopState);\n      });\n  };\n\n  onPopState = (_event: PopStateEvent) => {\n    const searchParams = new URLSearchParams(window.location.search);\n    const query = searchParams.get('q');\n    if (query) {\n      this.getElements().forEach((element) => {\n        element.setAttribute('value', query);\n        element.value = query;\n        const event = new Event('input');\n        // if element has focus the value will not be updated\n\n        element.blur();\n\n        element.dispatchEvent(event);\n      });\n    }\n  };\n\n  onSearch = async (event: Event) => {\n    const target = event.target as HTMLInputElement;\n    if (event.isTrusted) {\n      // get input name and add searchParams to the url\n      const searchParams = new URLSearchParams(window.location.search);\n      searchParams.set('q', target.value);\n      window.history.pushState(\n        { q: target.value },\n        '',\n        `${window.location.pathname}?${searchParams.toString()}`\n      );\n    }\n\n    let renderTarget =\n      target.closest('search')?.querySelector(this.searchResultsSelector) ||\n      target.closest('form')?.querySelector(this.searchResultsSelector) ||\n      target.closest('div')?.querySelector(this.searchResultsSelector);\n\n    if (!renderTarget) {\n      // create a new div element next to the form of the input.\n      renderTarget = document.createElement('div');\n      renderTarget.className = 'static-snap-search-results';\n      const parentSearch =\n        target.closest('search') || target.closest('form') || target.closest('div');\n      if (parentSearch) {\n        parentSearch.appendChild(renderTarget);\n      } else {\n        console.error('No suitable parent found to append search results');\n        return;\n      }\n    }\n\n    const results = await this.searchModule.search(target.value);\n    this.searchModule.renderResults(renderTarget as HTMLElement, results);\n  };\n}\n","module.exports = window[\"wp\"][\"i18n\"];","/**\n * Fuse.js v7.0.0 - Lightweight fuzzy-search (http://fusejs.io)\n *\n * Copyright (c) 2023 Kiro Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n */\n\nfunction isArray(value) {\n  return !Array.isArray\n    ? getTag(value) === '[object Array]'\n    : Array.isArray(value)\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js\nconst INFINITY = 1 / 0;\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value\n  }\n  let result = value + '';\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result\n}\n\nfunction toString(value) {\n  return value == null ? '' : baseToString(value)\n}\n\nfunction isString(value) {\n  return typeof value === 'string'\n}\n\nfunction isNumber(value) {\n  return typeof value === 'number'\n}\n\n// Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js\nfunction isBoolean(value) {\n  return (\n    value === true ||\n    value === false ||\n    (isObjectLike(value) && getTag(value) == '[object Boolean]')\n  )\n}\n\nfunction isObject(value) {\n  return typeof value === 'object'\n}\n\n// Checks if `value` is object-like.\nfunction isObjectLike(value) {\n  return isObject(value) && value !== null\n}\n\nfunction isDefined(value) {\n  return value !== undefined && value !== null\n}\n\nfunction isBlank(value) {\n  return !value.trim().length\n}\n\n// Gets the `toStringTag` of `value`.\n// Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js\nfunction getTag(value) {\n  return value == null\n    ? value === undefined\n      ? '[object Undefined]'\n      : '[object Null]'\n    : Object.prototype.toString.call(value)\n}\n\nconst EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';\n\nconst INCORRECT_INDEX_TYPE = \"Incorrect 'index' type\";\n\nconst LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) =>\n  `Invalid value for key ${key}`;\n\nconst PATTERN_LENGTH_TOO_LARGE = (max) =>\n  `Pattern length exceeds max of ${max}.`;\n\nconst MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;\n\nconst INVALID_KEY_WEIGHT_VALUE = (key) =>\n  `Property 'weight' in key '${key}' must be a positive integer`;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\n\nclass KeyStore {\n  constructor(keys) {\n    this._keys = [];\n    this._keyMap = {};\n\n    let totalWeight = 0;\n\n    keys.forEach((key) => {\n      let obj = createKey(key);\n\n      this._keys.push(obj);\n      this._keyMap[obj.id] = obj;\n\n      totalWeight += obj.weight;\n    });\n\n    // Normalize weights so that their sum is equal to 1\n    this._keys.forEach((key) => {\n      key.weight /= totalWeight;\n    });\n  }\n  get(keyId) {\n    return this._keyMap[keyId]\n  }\n  keys() {\n    return this._keys\n  }\n  toJSON() {\n    return JSON.stringify(this._keys)\n  }\n}\n\nfunction createKey(key) {\n  let path = null;\n  let id = null;\n  let src = null;\n  let weight = 1;\n  let getFn = null;\n\n  if (isString(key) || isArray(key)) {\n    src = key;\n    path = createKeyPath(key);\n    id = createKeyId(key);\n  } else {\n    if (!hasOwn.call(key, 'name')) {\n      throw new Error(MISSING_KEY_PROPERTY('name'))\n    }\n\n    const name = key.name;\n    src = name;\n\n    if (hasOwn.call(key, 'weight')) {\n      weight = key.weight;\n\n      if (weight <= 0) {\n        throw new Error(INVALID_KEY_WEIGHT_VALUE(name))\n      }\n    }\n\n    path = createKeyPath(name);\n    id = createKeyId(name);\n    getFn = key.getFn;\n  }\n\n  return { path, id, weight, src, getFn }\n}\n\nfunction createKeyPath(key) {\n  return isArray(key) ? key : key.split('.')\n}\n\nfunction createKeyId(key) {\n  return isArray(key) ? key.join('.') : key\n}\n\nfunction get(obj, path) {\n  let list = [];\n  let arr = false;\n\n  const deepGet = (obj, path, index) => {\n    if (!isDefined(obj)) {\n      return\n    }\n    if (!path[index]) {\n      // If there's no path left, we've arrived at the object we care about.\n      list.push(obj);\n    } else {\n      let key = path[index];\n\n      const value = obj[key];\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      // If we're at the last value in the path, and if it's a string/number/bool,\n      // add it to the list\n      if (\n        index === path.length - 1 &&\n        (isString(value) || isNumber(value) || isBoolean(value))\n      ) {\n        list.push(toString(value));\n      } else if (isArray(value)) {\n        arr = true;\n        // Search each item in the array.\n        for (let i = 0, len = value.length; i < len; i += 1) {\n          deepGet(value[i], path, index + 1);\n        }\n      } else if (path.length) {\n        // An object. Recurse further.\n        deepGet(value, path, index + 1);\n      }\n    }\n  };\n\n  // Backwards compatibility (since path used to be a string)\n  deepGet(obj, isString(path) ? path.split('.') : path, 0);\n\n  return arr ? list : list[0]\n}\n\nconst MatchOptions = {\n  // Whether the matches should be included in the result set. When `true`, each record in the result\n  // set will include the indices of the matched characters.\n  // These can consequently be used for highlighting purposes.\n  includeMatches: false,\n  // When `true`, the matching function will continue to the end of a search pattern even if\n  // a perfect match has already been located in the string.\n  findAllMatches: false,\n  // Minimum number of characters that must be matched before a result is considered a match\n  minMatchCharLength: 1\n};\n\nconst BasicOptions = {\n  // When `true`, the algorithm continues searching to the end of the input even if a perfect\n  // match is found before the end of the same input.\n  isCaseSensitive: false,\n  // When true, the matching function will continue to the end of a search pattern even if\n  includeScore: false,\n  // List of properties that will be searched. This also supports nested properties.\n  keys: [],\n  // Whether to sort the result list, by score\n  shouldSort: true,\n  // Default sort function: sort by ascending score, ascending index\n  sortFn: (a, b) =>\n    a.score === b.score ? (a.idx < b.idx ? -1 : 1) : a.score < b.score ? -1 : 1\n};\n\nconst FuzzyOptions = {\n  // Approximately where in the text is the pattern expected to be found?\n  location: 0,\n  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match\n  // (of both letters and location), a threshold of '1.0' would match anything.\n  threshold: 0.6,\n  // Determines how close the match must be to the fuzzy location (specified above).\n  // An exact letter match which is 'distance' characters away from the fuzzy location\n  // would score as a complete mismatch. A distance of '0' requires the match be at\n  // the exact location specified, a threshold of '1000' would require a perfect match\n  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.\n  distance: 100\n};\n\nconst AdvancedOptions = {\n  // When `true`, it enables the use of unix-like search commands\n  useExtendedSearch: false,\n  // The get function to use when fetching an object's properties.\n  // The default will search nested paths *ie foo.bar.baz*\n  getFn: get,\n  // When `true`, search will ignore `location` and `distance`, so it won't matter\n  // where in the string the pattern appears.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score\n  ignoreLocation: false,\n  // When `true`, the calculation for the relevance score (used for sorting) will\n  // ignore the field-length norm.\n  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm\n  ignoreFieldNorm: false,\n  // The weight to determine how much field length norm effects scoring.\n  fieldNormWeight: 1\n};\n\nvar Config = {\n  ...BasicOptions,\n  ...MatchOptions,\n  ...FuzzyOptions,\n  ...AdvancedOptions\n};\n\nconst SPACE = /[^ ]+/g;\n\n// Field-length norm: the shorter the field, the higher the weight.\n// Set to 3 decimals to reduce index size.\nfunction norm(weight = 1, mantissa = 3) {\n  const cache = new Map();\n  const m = Math.pow(10, mantissa);\n\n  return {\n    get(value) {\n      const numTokens = value.match(SPACE).length;\n\n      if (cache.has(numTokens)) {\n        return cache.get(numTokens)\n      }\n\n      // Default function is 1/sqrt(x), weight makes that variable\n      const norm = 1 / Math.pow(numTokens, 0.5 * weight);\n\n      // In place of `toFixed(mantissa)`, for faster computation\n      const n = parseFloat(Math.round(norm * m) / m);\n\n      cache.set(numTokens, n);\n\n      return n\n    },\n    clear() {\n      cache.clear();\n    }\n  }\n}\n\nclass FuseIndex {\n  constructor({\n    getFn = Config.getFn,\n    fieldNormWeight = Config.fieldNormWeight\n  } = {}) {\n    this.norm = norm(fieldNormWeight, 3);\n    this.getFn = getFn;\n    this.isCreated = false;\n\n    this.setIndexRecords();\n  }\n  setSources(docs = []) {\n    this.docs = docs;\n  }\n  setIndexRecords(records = []) {\n    this.records = records;\n  }\n  setKeys(keys = []) {\n    this.keys = keys;\n    this._keysMap = {};\n    keys.forEach((key, idx) => {\n      this._keysMap[key.id] = idx;\n    });\n  }\n  create() {\n    if (this.isCreated || !this.docs.length) {\n      return\n    }\n\n    this.isCreated = true;\n\n    // List is Array<String>\n    if (isString(this.docs[0])) {\n      this.docs.forEach((doc, docIndex) => {\n        this._addString(doc, docIndex);\n      });\n    } else {\n      // List is Array<Object>\n      this.docs.forEach((doc, docIndex) => {\n        this._addObject(doc, docIndex);\n      });\n    }\n\n    this.norm.clear();\n  }\n  // Adds a doc to the end of the index\n  add(doc) {\n    const idx = this.size();\n\n    if (isString(doc)) {\n      this._addString(doc, idx);\n    } else {\n      this._addObject(doc, idx);\n    }\n  }\n  // Removes the doc at the specified index of the index\n  removeAt(idx) {\n    this.records.splice(idx, 1);\n\n    // Change ref index of every subsquent doc\n    for (let i = idx, len = this.size(); i < len; i += 1) {\n      this.records[i].i -= 1;\n    }\n  }\n  getValueForItemAtKeyId(item, keyId) {\n    return item[this._keysMap[keyId]]\n  }\n  size() {\n    return this.records.length\n  }\n  _addString(doc, docIndex) {\n    if (!isDefined(doc) || isBlank(doc)) {\n      return\n    }\n\n    let record = {\n      v: doc,\n      i: docIndex,\n      n: this.norm.get(doc)\n    };\n\n    this.records.push(record);\n  }\n  _addObject(doc, docIndex) {\n    let record = { i: docIndex, $: {} };\n\n    // Iterate over every key (i.e, path), and fetch the value at that key\n    this.keys.forEach((key, keyIndex) => {\n      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);\n\n      if (!isDefined(value)) {\n        return\n      }\n\n      if (isArray(value)) {\n        let subRecords = [];\n        const stack = [{ nestedArrIndex: -1, value }];\n\n        while (stack.length) {\n          const { nestedArrIndex, value } = stack.pop();\n\n          if (!isDefined(value)) {\n            continue\n          }\n\n          if (isString(value) && !isBlank(value)) {\n            let subRecord = {\n              v: value,\n              i: nestedArrIndex,\n              n: this.norm.get(value)\n            };\n\n            subRecords.push(subRecord);\n          } else if (isArray(value)) {\n            value.forEach((item, k) => {\n              stack.push({\n                nestedArrIndex: k,\n                value: item\n              });\n            });\n          } else ;\n        }\n        record.$[keyIndex] = subRecords;\n      } else if (isString(value) && !isBlank(value)) {\n        let subRecord = {\n          v: value,\n          n: this.norm.get(value)\n        };\n\n        record.$[keyIndex] = subRecord;\n      }\n    });\n\n    this.records.push(record);\n  }\n  toJSON() {\n    return {\n      keys: this.keys,\n      records: this.records\n    }\n  }\n}\n\nfunction createIndex(\n  keys,\n  docs,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys.map(createKey));\n  myIndex.setSources(docs);\n  myIndex.create();\n  return myIndex\n}\n\nfunction parseIndex(\n  data,\n  { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}\n) {\n  const { keys, records } = data;\n  const myIndex = new FuseIndex({ getFn, fieldNormWeight });\n  myIndex.setKeys(keys);\n  myIndex.setIndexRecords(records);\n  return myIndex\n}\n\nfunction computeScore$1(\n  pattern,\n  {\n    errors = 0,\n    currentLocation = 0,\n    expectedLocation = 0,\n    distance = Config.distance,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  const accuracy = errors / pattern.length;\n\n  if (ignoreLocation) {\n    return accuracy\n  }\n\n  const proximity = Math.abs(expectedLocation - currentLocation);\n\n  if (!distance) {\n    // Dodge divide by zero error.\n    return proximity ? 1.0 : accuracy\n  }\n\n  return accuracy + proximity / distance\n}\n\nfunction convertMaskToIndices(\n  matchmask = [],\n  minMatchCharLength = Config.minMatchCharLength\n) {\n  let indices = [];\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (let len = matchmask.length; i < len; i += 1) {\n    let match = matchmask[i];\n    if (match && start === -1) {\n      start = i;\n    } else if (!match && start !== -1) {\n      end = i - 1;\n      if (end - start + 1 >= minMatchCharLength) {\n        indices.push([start, end]);\n      }\n      start = -1;\n    }\n  }\n\n  // (i-1 - start) + 1 => i - start\n  if (matchmask[i - 1] && i - start >= minMatchCharLength) {\n    indices.push([start, i - 1]);\n  }\n\n  return indices\n}\n\n// Machine word size\nconst MAX_BITS = 32;\n\nfunction search(\n  text,\n  pattern,\n  patternAlphabet,\n  {\n    location = Config.location,\n    distance = Config.distance,\n    threshold = Config.threshold,\n    findAllMatches = Config.findAllMatches,\n    minMatchCharLength = Config.minMatchCharLength,\n    includeMatches = Config.includeMatches,\n    ignoreLocation = Config.ignoreLocation\n  } = {}\n) {\n  if (pattern.length > MAX_BITS) {\n    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS))\n  }\n\n  const patternLen = pattern.length;\n  // Set starting location at beginning text and initialize the alphabet.\n  const textLen = text.length;\n  // Handle the case when location > text.length\n  const expectedLocation = Math.max(0, Math.min(location, textLen));\n  // Highest score beyond which we give up.\n  let currentThreshold = threshold;\n  // Is there a nearby exact match? (speedup)\n  let bestLocation = expectedLocation;\n\n  // Performance: only computer matches when the minMatchCharLength > 1\n  // OR if `includeMatches` is true.\n  const computeMatches = minMatchCharLength > 1 || includeMatches;\n  // A mask of the matches, used for building the indices\n  const matchMask = computeMatches ? Array(textLen) : [];\n\n  let index;\n\n  // Get all exact matches, here for speed up\n  while ((index = text.indexOf(pattern, bestLocation)) > -1) {\n    let score = computeScore$1(pattern, {\n      currentLocation: index,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    currentThreshold = Math.min(score, currentThreshold);\n    bestLocation = index + patternLen;\n\n    if (computeMatches) {\n      let i = 0;\n      while (i < patternLen) {\n        matchMask[index + i] = 1;\n        i += 1;\n      }\n    }\n  }\n\n  // Reset the best location\n  bestLocation = -1;\n\n  let lastBitArr = [];\n  let finalScore = 1;\n  let binMax = patternLen + textLen;\n\n  const mask = 1 << (patternLen - 1);\n\n  for (let i = 0; i < patternLen; i += 1) {\n    // Scan for the best match; each iteration allows for one more error.\n    // Run a binary search to determine how far from the match location we can stray\n    // at this error level.\n    let binMin = 0;\n    let binMid = binMax;\n\n    while (binMin < binMid) {\n      const score = computeScore$1(pattern, {\n        errors: i,\n        currentLocation: expectedLocation + binMid,\n        expectedLocation,\n        distance,\n        ignoreLocation\n      });\n\n      if (score <= currentThreshold) {\n        binMin = binMid;\n      } else {\n        binMax = binMid;\n      }\n\n      binMid = Math.floor((binMax - binMin) / 2 + binMin);\n    }\n\n    // Use the result from this iteration as the maximum for the next.\n    binMax = binMid;\n\n    let start = Math.max(1, expectedLocation - binMid + 1);\n    let finish = findAllMatches\n      ? textLen\n      : Math.min(expectedLocation + binMid, textLen) + patternLen;\n\n    // Initialize the bit array\n    let bitArr = Array(finish + 2);\n\n    bitArr[finish + 1] = (1 << i) - 1;\n\n    for (let j = finish; j >= start; j -= 1) {\n      let currentLocation = j - 1;\n      let charMatch = patternAlphabet[text.charAt(currentLocation)];\n\n      if (computeMatches) {\n        // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)\n        matchMask[currentLocation] = +!!charMatch;\n      }\n\n      // First pass: exact match\n      bitArr[j] = ((bitArr[j + 1] << 1) | 1) & charMatch;\n\n      // Subsequent passes: fuzzy match\n      if (i) {\n        bitArr[j] |=\n          ((lastBitArr[j + 1] | lastBitArr[j]) << 1) | 1 | lastBitArr[j + 1];\n      }\n\n      if (bitArr[j] & mask) {\n        finalScore = computeScore$1(pattern, {\n          errors: i,\n          currentLocation,\n          expectedLocation,\n          distance,\n          ignoreLocation\n        });\n\n        // This match will almost certainly be better than any existing match.\n        // But check anyway.\n        if (finalScore <= currentThreshold) {\n          // Indeed it is\n          currentThreshold = finalScore;\n          bestLocation = currentLocation;\n\n          // Already passed `loc`, downhill from here on in.\n          if (bestLocation <= expectedLocation) {\n            break\n          }\n\n          // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.\n          start = Math.max(1, 2 * expectedLocation - bestLocation);\n        }\n      }\n    }\n\n    // No hope for a (better) match at greater error levels.\n    const score = computeScore$1(pattern, {\n      errors: i + 1,\n      currentLocation: expectedLocation,\n      expectedLocation,\n      distance,\n      ignoreLocation\n    });\n\n    if (score > currentThreshold) {\n      break\n    }\n\n    lastBitArr = bitArr;\n  }\n\n  const result = {\n    isMatch: bestLocation >= 0,\n    // Count exact matches (those with a score of 0) to be \"almost\" exact\n    score: Math.max(0.001, finalScore)\n  };\n\n  if (computeMatches) {\n    const indices = convertMaskToIndices(matchMask, minMatchCharLength);\n    if (!indices.length) {\n      result.isMatch = false;\n    } else if (includeMatches) {\n      result.indices = indices;\n    }\n  }\n\n  return result\n}\n\nfunction createPatternAlphabet(pattern) {\n  let mask = {};\n\n  for (let i = 0, len = pattern.length; i < len; i += 1) {\n    const char = pattern.charAt(i);\n    mask[char] = (mask[char] || 0) | (1 << (len - i - 1));\n  }\n\n  return mask\n}\n\nclass BitapSearch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    this.options = {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n\n    this.chunks = [];\n\n    if (!this.pattern.length) {\n      return\n    }\n\n    const addChunk = (pattern, startIndex) => {\n      this.chunks.push({\n        pattern,\n        alphabet: createPatternAlphabet(pattern),\n        startIndex\n      });\n    };\n\n    const len = this.pattern.length;\n\n    if (len > MAX_BITS) {\n      let i = 0;\n      const remainder = len % MAX_BITS;\n      const end = len - remainder;\n\n      while (i < end) {\n        addChunk(this.pattern.substr(i, MAX_BITS), i);\n        i += MAX_BITS;\n      }\n\n      if (remainder) {\n        const startIndex = len - MAX_BITS;\n        addChunk(this.pattern.substr(startIndex), startIndex);\n      }\n    } else {\n      addChunk(this.pattern, 0);\n    }\n  }\n\n  searchIn(text) {\n    const { isCaseSensitive, includeMatches } = this.options;\n\n    if (!isCaseSensitive) {\n      text = text.toLowerCase();\n    }\n\n    // Exact match\n    if (this.pattern === text) {\n      let result = {\n        isMatch: true,\n        score: 0\n      };\n\n      if (includeMatches) {\n        result.indices = [[0, text.length - 1]];\n      }\n\n      return result\n    }\n\n    // Otherwise, use Bitap algorithm\n    const {\n      location,\n      distance,\n      threshold,\n      findAllMatches,\n      minMatchCharLength,\n      ignoreLocation\n    } = this.options;\n\n    let allIndices = [];\n    let totalScore = 0;\n    let hasMatches = false;\n\n    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {\n      const { isMatch, score, indices } = search(text, pattern, alphabet, {\n        location: location + startIndex,\n        distance,\n        threshold,\n        findAllMatches,\n        minMatchCharLength,\n        includeMatches,\n        ignoreLocation\n      });\n\n      if (isMatch) {\n        hasMatches = true;\n      }\n\n      totalScore += score;\n\n      if (isMatch && indices) {\n        allIndices = [...allIndices, ...indices];\n      }\n    });\n\n    let result = {\n      isMatch: hasMatches,\n      score: hasMatches ? totalScore / this.chunks.length : 1\n    };\n\n    if (hasMatches && includeMatches) {\n      result.indices = allIndices;\n    }\n\n    return result\n  }\n}\n\nclass BaseMatch {\n  constructor(pattern) {\n    this.pattern = pattern;\n  }\n  static isMultiMatch(pattern) {\n    return getMatch(pattern, this.multiRegex)\n  }\n  static isSingleMatch(pattern) {\n    return getMatch(pattern, this.singleRegex)\n  }\n  search(/*text*/) {}\n}\n\nfunction getMatch(pattern, exp) {\n  const matches = pattern.match(exp);\n  return matches ? matches[1] : null\n}\n\n// Token: 'file\n\nclass ExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'exact'\n  }\n  static get multiRegex() {\n    return /^=\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^=(.*)$/\n  }\n  search(text) {\n    const isMatch = text === this.pattern;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !fire\n\nclass InverseExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!(.*)$/\n  }\n  search(text) {\n    const index = text.indexOf(this.pattern);\n    const isMatch = index === -1;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: ^file\n\nclass PrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'prefix-exact'\n  }\n  static get multiRegex() {\n    return /^\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, this.pattern.length - 1]\n    }\n  }\n}\n\n// Token: !^fire\n\nclass InversePrefixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-prefix-exact'\n  }\n  static get multiRegex() {\n    return /^!\\^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^!\\^(.*)$/\n  }\n  search(text) {\n    const isMatch = !text.startsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\n// Token: .file$\n\nclass SuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'suffix-exact'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = text.endsWith(this.pattern);\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [text.length - this.pattern.length, text.length - 1]\n    }\n  }\n}\n\n// Token: !.file$\n\nclass InverseSuffixExactMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'inverse-suffix-exact'\n  }\n  static get multiRegex() {\n    return /^!\"(.*)\"\\$$/\n  }\n  static get singleRegex() {\n    return /^!(.*)\\$$/\n  }\n  search(text) {\n    const isMatch = !text.endsWith(this.pattern);\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices: [0, text.length - 1]\n    }\n  }\n}\n\nclass FuzzyMatch extends BaseMatch {\n  constructor(\n    pattern,\n    {\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance,\n      includeMatches = Config.includeMatches,\n      findAllMatches = Config.findAllMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      isCaseSensitive = Config.isCaseSensitive,\n      ignoreLocation = Config.ignoreLocation\n    } = {}\n  ) {\n    super(pattern);\n    this._bitapSearch = new BitapSearch(pattern, {\n      location,\n      threshold,\n      distance,\n      includeMatches,\n      findAllMatches,\n      minMatchCharLength,\n      isCaseSensitive,\n      ignoreLocation\n    });\n  }\n  static get type() {\n    return 'fuzzy'\n  }\n  static get multiRegex() {\n    return /^\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^(.*)$/\n  }\n  search(text) {\n    return this._bitapSearch.searchIn(text)\n  }\n}\n\n// Token: 'file\n\nclass IncludeMatch extends BaseMatch {\n  constructor(pattern) {\n    super(pattern);\n  }\n  static get type() {\n    return 'include'\n  }\n  static get multiRegex() {\n    return /^'\"(.*)\"$/\n  }\n  static get singleRegex() {\n    return /^'(.*)$/\n  }\n  search(text) {\n    let location = 0;\n    let index;\n\n    const indices = [];\n    const patternLen = this.pattern.length;\n\n    // Get all exact matches\n    while ((index = text.indexOf(this.pattern, location)) > -1) {\n      location = index + patternLen;\n      indices.push([index, location - 1]);\n    }\n\n    const isMatch = !!indices.length;\n\n    return {\n      isMatch,\n      score: isMatch ? 0 : 1,\n      indices\n    }\n  }\n}\n\n// Order is important. DO NOT CHANGE.\nconst searchers = [\n  ExactMatch,\n  IncludeMatch,\n  PrefixExactMatch,\n  InversePrefixExactMatch,\n  InverseSuffixExactMatch,\n  SuffixExactMatch,\n  InverseExactMatch,\n  FuzzyMatch\n];\n\nconst searchersLen = searchers.length;\n\n// Regex to split by spaces, but keep anything in quotes together\nconst SPACE_RE = / +(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)/;\nconst OR_TOKEN = '|';\n\n// Return a 2D array representation of the query, for simpler parsing.\n// Example:\n// \"^core go$ | rb$ | py$ xy$\" => [[\"^core\", \"go$\"], [\"rb$\"], [\"py$\", \"xy$\"]]\nfunction parseQuery(pattern, options = {}) {\n  return pattern.split(OR_TOKEN).map((item) => {\n    let query = item\n      .trim()\n      .split(SPACE_RE)\n      .filter((item) => item && !!item.trim());\n\n    let results = [];\n    for (let i = 0, len = query.length; i < len; i += 1) {\n      const queryItem = query[i];\n\n      // 1. Handle multiple query match (i.e, once that are quoted, like `\"hello world\"`)\n      let found = false;\n      let idx = -1;\n      while (!found && ++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isMultiMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          found = true;\n        }\n      }\n\n      if (found) {\n        continue\n      }\n\n      // 2. Handle single query matches (i.e, once that are *not* quoted)\n      idx = -1;\n      while (++idx < searchersLen) {\n        const searcher = searchers[idx];\n        let token = searcher.isSingleMatch(queryItem);\n        if (token) {\n          results.push(new searcher(token, options));\n          break\n        }\n      }\n    }\n\n    return results\n  })\n}\n\n// These extended matchers can return an array of matches, as opposed\n// to a singl match\nconst MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);\n\n/**\n * Command-like searching\n * ======================\n *\n * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,\n * search in a given text.\n *\n * Search syntax:\n *\n * | Token       | Match type                 | Description                            |\n * | ----------- | -------------------------- | -------------------------------------- |\n * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |\n * | `=scheme`   | exact-match                | Items that are `scheme`                |\n * | `'python`   | include-match              | Items that include `python`            |\n * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |\n * | `^java`     | prefix-exact-match         | Items that start with `java`           |\n * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |\n * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |\n * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |\n *\n * A single pipe character acts as an OR operator. For example, the following\n * query matches entries that start with `core` and end with either`go`, `rb`,\n * or`py`.\n *\n * ```\n * ^core go$ | rb$ | py$\n * ```\n */\nclass ExtendedSearch {\n  constructor(\n    pattern,\n    {\n      isCaseSensitive = Config.isCaseSensitive,\n      includeMatches = Config.includeMatches,\n      minMatchCharLength = Config.minMatchCharLength,\n      ignoreLocation = Config.ignoreLocation,\n      findAllMatches = Config.findAllMatches,\n      location = Config.location,\n      threshold = Config.threshold,\n      distance = Config.distance\n    } = {}\n  ) {\n    this.query = null;\n    this.options = {\n      isCaseSensitive,\n      includeMatches,\n      minMatchCharLength,\n      findAllMatches,\n      ignoreLocation,\n      location,\n      threshold,\n      distance\n    };\n\n    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();\n    this.query = parseQuery(this.pattern, this.options);\n  }\n\n  static condition(_, options) {\n    return options.useExtendedSearch\n  }\n\n  searchIn(text) {\n    const query = this.query;\n\n    if (!query) {\n      return {\n        isMatch: false,\n        score: 1\n      }\n    }\n\n    const { includeMatches, isCaseSensitive } = this.options;\n\n    text = isCaseSensitive ? text : text.toLowerCase();\n\n    let numMatches = 0;\n    let allIndices = [];\n    let totalScore = 0;\n\n    // ORs\n    for (let i = 0, qLen = query.length; i < qLen; i += 1) {\n      const searchers = query[i];\n\n      // Reset indices\n      allIndices.length = 0;\n      numMatches = 0;\n\n      // ANDs\n      for (let j = 0, pLen = searchers.length; j < pLen; j += 1) {\n        const searcher = searchers[j];\n        const { isMatch, indices, score } = searcher.search(text);\n\n        if (isMatch) {\n          numMatches += 1;\n          totalScore += score;\n          if (includeMatches) {\n            const type = searcher.constructor.type;\n            if (MultiMatchSet.has(type)) {\n              allIndices = [...allIndices, ...indices];\n            } else {\n              allIndices.push(indices);\n            }\n          }\n        } else {\n          totalScore = 0;\n          numMatches = 0;\n          allIndices.length = 0;\n          break\n        }\n      }\n\n      // OR condition, so if TRUE, return\n      if (numMatches) {\n        let result = {\n          isMatch: true,\n          score: totalScore / numMatches\n        };\n\n        if (includeMatches) {\n          result.indices = allIndices;\n        }\n\n        return result\n      }\n    }\n\n    // Nothing was matched\n    return {\n      isMatch: false,\n      score: 1\n    }\n  }\n}\n\nconst registeredSearchers = [];\n\nfunction register(...args) {\n  registeredSearchers.push(...args);\n}\n\nfunction createSearcher(pattern, options) {\n  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {\n    let searcherClass = registeredSearchers[i];\n    if (searcherClass.condition(pattern, options)) {\n      return new searcherClass(pattern, options)\n    }\n  }\n\n  return new BitapSearch(pattern, options)\n}\n\nconst LogicalOperator = {\n  AND: '$and',\n  OR: '$or'\n};\n\nconst KeyType = {\n  PATH: '$path',\n  PATTERN: '$val'\n};\n\nconst isExpression = (query) =>\n  !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);\n\nconst isPath = (query) => !!query[KeyType.PATH];\n\nconst isLeaf = (query) =>\n  !isArray(query) && isObject(query) && !isExpression(query);\n\nconst convertToExplicit = (query) => ({\n  [LogicalOperator.AND]: Object.keys(query).map((key) => ({\n    [key]: query[key]\n  }))\n});\n\n// When `auto` is `true`, the parse function will infer and initialize and add\n// the appropriate `Searcher` instance\nfunction parse(query, options, { auto = true } = {}) {\n  const next = (query) => {\n    let keys = Object.keys(query);\n\n    const isQueryPath = isPath(query);\n\n    if (!isQueryPath && keys.length > 1 && !isExpression(query)) {\n      return next(convertToExplicit(query))\n    }\n\n    if (isLeaf(query)) {\n      const key = isQueryPath ? query[KeyType.PATH] : keys[0];\n\n      const pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];\n\n      if (!isString(pattern)) {\n        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key))\n      }\n\n      const obj = {\n        keyId: createKeyId(key),\n        pattern\n      };\n\n      if (auto) {\n        obj.searcher = createSearcher(pattern, options);\n      }\n\n      return obj\n    }\n\n    let node = {\n      children: [],\n      operator: keys[0]\n    };\n\n    keys.forEach((key) => {\n      const value = query[key];\n\n      if (isArray(value)) {\n        value.forEach((item) => {\n          node.children.push(next(item));\n        });\n      }\n    });\n\n    return node\n  };\n\n  if (!isExpression(query)) {\n    query = convertToExplicit(query);\n  }\n\n  return next(query)\n}\n\n// Practical scoring function\nfunction computeScore(\n  results,\n  { ignoreFieldNorm = Config.ignoreFieldNorm }\n) {\n  results.forEach((result) => {\n    let totalScore = 1;\n\n    result.matches.forEach(({ key, norm, score }) => {\n      const weight = key ? key.weight : null;\n\n      totalScore *= Math.pow(\n        score === 0 && weight ? Number.EPSILON : score,\n        (weight || 1) * (ignoreFieldNorm ? 1 : norm)\n      );\n    });\n\n    result.score = totalScore;\n  });\n}\n\nfunction transformMatches(result, data) {\n  const matches = result.matches;\n  data.matches = [];\n\n  if (!isDefined(matches)) {\n    return\n  }\n\n  matches.forEach((match) => {\n    if (!isDefined(match.indices) || !match.indices.length) {\n      return\n    }\n\n    const { indices, value } = match;\n\n    let obj = {\n      indices,\n      value\n    };\n\n    if (match.key) {\n      obj.key = match.key.src;\n    }\n\n    if (match.idx > -1) {\n      obj.refIndex = match.idx;\n    }\n\n    data.matches.push(obj);\n  });\n}\n\nfunction transformScore(result, data) {\n  data.score = result.score;\n}\n\nfunction format(\n  results,\n  docs,\n  {\n    includeMatches = Config.includeMatches,\n    includeScore = Config.includeScore\n  } = {}\n) {\n  const transformers = [];\n\n  if (includeMatches) transformers.push(transformMatches);\n  if (includeScore) transformers.push(transformScore);\n\n  return results.map((result) => {\n    const { idx } = result;\n\n    const data = {\n      item: docs[idx],\n      refIndex: idx\n    };\n\n    if (transformers.length) {\n      transformers.forEach((transformer) => {\n        transformer(result, data);\n      });\n    }\n\n    return data\n  })\n}\n\nclass Fuse {\n  constructor(docs, options = {}, index) {\n    this.options = { ...Config, ...options };\n\n    if (\n      this.options.useExtendedSearch &&\n      !true\n    ) {\n      throw new Error(EXTENDED_SEARCH_UNAVAILABLE)\n    }\n\n    this._keyStore = new KeyStore(this.options.keys);\n\n    this.setCollection(docs, index);\n  }\n\n  setCollection(docs, index) {\n    this._docs = docs;\n\n    if (index && !(index instanceof FuseIndex)) {\n      throw new Error(INCORRECT_INDEX_TYPE)\n    }\n\n    this._myIndex =\n      index ||\n      createIndex(this.options.keys, this._docs, {\n        getFn: this.options.getFn,\n        fieldNormWeight: this.options.fieldNormWeight\n      });\n  }\n\n  add(doc) {\n    if (!isDefined(doc)) {\n      return\n    }\n\n    this._docs.push(doc);\n    this._myIndex.add(doc);\n  }\n\n  remove(predicate = (/* doc, idx */) => false) {\n    const results = [];\n\n    for (let i = 0, len = this._docs.length; i < len; i += 1) {\n      const doc = this._docs[i];\n      if (predicate(doc, i)) {\n        this.removeAt(i);\n        i -= 1;\n        len -= 1;\n\n        results.push(doc);\n      }\n    }\n\n    return results\n  }\n\n  removeAt(idx) {\n    this._docs.splice(idx, 1);\n    this._myIndex.removeAt(idx);\n  }\n\n  getIndex() {\n    return this._myIndex\n  }\n\n  search(query, { limit = -1 } = {}) {\n    const {\n      includeMatches,\n      includeScore,\n      shouldSort,\n      sortFn,\n      ignoreFieldNorm\n    } = this.options;\n\n    let results = isString(query)\n      ? isString(this._docs[0])\n        ? this._searchStringList(query)\n        : this._searchObjectList(query)\n      : this._searchLogical(query);\n\n    computeScore(results, { ignoreFieldNorm });\n\n    if (shouldSort) {\n      results.sort(sortFn);\n    }\n\n    if (isNumber(limit) && limit > -1) {\n      results = results.slice(0, limit);\n    }\n\n    return format(results, this._docs, {\n      includeMatches,\n      includeScore\n    })\n  }\n\n  _searchStringList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { records } = this._myIndex;\n    const results = [];\n\n    // Iterate over every string in the index\n    records.forEach(({ v: text, i: idx, n: norm }) => {\n      if (!isDefined(text)) {\n        return\n      }\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        results.push({\n          item: text,\n          idx,\n          matches: [{ score, value: text, norm, indices }]\n        });\n      }\n    });\n\n    return results\n  }\n\n  _searchLogical(query) {\n\n    const expression = parse(query, this.options);\n\n    const evaluate = (node, item, idx) => {\n      if (!node.children) {\n        const { keyId, searcher } = node;\n\n        const matches = this._findMatches({\n          key: this._keyStore.get(keyId),\n          value: this._myIndex.getValueForItemAtKeyId(item, keyId),\n          searcher\n        });\n\n        if (matches && matches.length) {\n          return [\n            {\n              idx,\n              item,\n              matches\n            }\n          ]\n        }\n\n        return []\n      }\n\n      const res = [];\n      for (let i = 0, len = node.children.length; i < len; i += 1) {\n        const child = node.children[i];\n        const result = evaluate(child, item, idx);\n        if (result.length) {\n          res.push(...result);\n        } else if (node.operator === LogicalOperator.AND) {\n          return []\n        }\n      }\n      return res\n    };\n\n    const records = this._myIndex.records;\n    const resultMap = {};\n    const results = [];\n\n    records.forEach(({ $: item, i: idx }) => {\n      if (isDefined(item)) {\n        let expResults = evaluate(expression, item, idx);\n\n        if (expResults.length) {\n          // Dedupe when adding\n          if (!resultMap[idx]) {\n            resultMap[idx] = { idx, item, matches: [] };\n            results.push(resultMap[idx]);\n          }\n          expResults.forEach(({ matches }) => {\n            resultMap[idx].matches.push(...matches);\n          });\n        }\n      }\n    });\n\n    return results\n  }\n\n  _searchObjectList(query) {\n    const searcher = createSearcher(query, this.options);\n    const { keys, records } = this._myIndex;\n    const results = [];\n\n    // List is Array<Object>\n    records.forEach(({ $: item, i: idx }) => {\n      if (!isDefined(item)) {\n        return\n      }\n\n      let matches = [];\n\n      // Iterate over every key (i.e, path), and fetch the value at that key\n      keys.forEach((key, keyIndex) => {\n        matches.push(\n          ...this._findMatches({\n            key,\n            value: item[keyIndex],\n            searcher\n          })\n        );\n      });\n\n      if (matches.length) {\n        results.push({\n          idx,\n          item,\n          matches\n        });\n      }\n    });\n\n    return results\n  }\n  _findMatches({ key, value, searcher }) {\n    if (!isDefined(value)) {\n      return []\n    }\n\n    let matches = [];\n\n    if (isArray(value)) {\n      value.forEach(({ v: text, i: idx, n: norm }) => {\n        if (!isDefined(text)) {\n          return\n        }\n\n        const { isMatch, score, indices } = searcher.searchIn(text);\n\n        if (isMatch) {\n          matches.push({\n            score,\n            key,\n            value: text,\n            idx,\n            norm,\n            indices\n          });\n        }\n      });\n    } else {\n      const { v: text, n: norm } = value;\n\n      const { isMatch, score, indices } = searcher.searchIn(text);\n\n      if (isMatch) {\n        matches.push({ score, key, value: text, norm, indices });\n      }\n    }\n\n    return matches\n  }\n}\n\nFuse.version = '7.0.0';\nFuse.createIndex = createIndex;\nFuse.parseIndex = parseIndex;\nFuse.config = Config;\n\n{\n  Fuse.parseQuery = parse;\n}\n\n{\n  register(ExtendedSearch);\n}\n\nexport { Fuse as default };\n","/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\nvar objectToString = Object.prototype.toString;\nvar isArray = Array.isArray || function isArrayPolyfill (object) {\n  return objectToString.call(object) === '[object Array]';\n};\n\nfunction isFunction (object) {\n  return typeof object === 'function';\n}\n\n/**\n * More correct typeof string handling array\n * which normally returns typeof 'object'\n */\nfunction typeStr (obj) {\n  return isArray(obj) ? 'array' : typeof obj;\n}\n\nfunction escapeRegExp (string) {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&');\n}\n\n/**\n * Null safe way of checking whether or not an object,\n * including its prototype, has a given property\n */\nfunction hasProperty (obj, propName) {\n  return obj != null && typeof obj === 'object' && (propName in obj);\n}\n\n/**\n * Safe way of detecting whether or not the given thing is a primitive and\n * whether it has the given property\n */\nfunction primitiveHasOwnProperty (primitive, propName) {\n  return (\n    primitive != null\n    && typeof primitive !== 'object'\n    && primitive.hasOwnProperty\n    && primitive.hasOwnProperty(propName)\n  );\n}\n\n// Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n// See https://github.com/janl/mustache.js/issues/189\nvar regExpTest = RegExp.prototype.test;\nfunction testRegExp (re, string) {\n  return regExpTest.call(re, string);\n}\n\nvar nonSpaceRe = /\\S/;\nfunction isWhitespace (string) {\n  return !testRegExp(nonSpaceRe, string);\n}\n\nvar entityMap = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;'\n};\n\nfunction escapeHtml (string) {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap (s) {\n    return entityMap[s];\n  });\n}\n\nvar whiteRe = /\\s*/;\nvar spaceRe = /\\s+/;\nvar equalsRe = /\\s*=/;\nvar curlyRe = /\\s*\\}/;\nvar tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n/**\n * Breaks up the given `template` string into a tree of tokens. If the `tags`\n * argument is given here it must be an array with two string values: the\n * opening and closing tags used in the template (e.g. [ \"<%\", \"%>\" ]). Of\n * course, the default is to use mustaches (i.e. mustache.tags).\n *\n * A token is an array with at least 4 elements. The first element is the\n * mustache symbol that was used inside the tag, e.g. \"#\" or \"&\". If the tag\n * did not contain a symbol (i.e. {{myValue}}) this element is \"name\". For\n * all text that appears outside a symbol this element is \"text\".\n *\n * The second element of a token is its \"value\". For mustache tags this is\n * whatever else was inside the tag besides the opening symbol. For text tokens\n * this is the text itself.\n *\n * The third and fourth elements of the token are the start and end indices,\n * respectively, of the token in the original template.\n *\n * Tokens that are the root node of a subtree contain two more elements: 1) an\n * array of tokens in the subtree and 2) the index in the original template at\n * which the closing tag for that section begins.\n *\n * Tokens for partials also contain two more elements: 1) a string value of\n * indendation prior to that tag and 2) the index of that tag on that line -\n * eg a value of 2 indicates the partial is the third tag on this line.\n */\nfunction parseTemplate (template, tags) {\n  if (!template)\n    return [];\n  var lineHasNonSpace = false;\n  var sections = [];     // Stack to hold section tokens\n  var tokens = [];       // Buffer to hold the tokens\n  var spaces = [];       // Indices of whitespace tokens on the current line\n  var hasTag = false;    // Is there a {{tag}} on the current line?\n  var nonSpace = false;  // Is there a non-space char on the current line?\n  var indentation = '';  // Tracks indentation for tags that use it\n  var tagIndex = 0;      // Stores a count of number of tags encountered on a line\n\n  // Strips all whitespace tokens array for the current line\n  // if there was a {{#tag}} on it and otherwise only space.\n  function stripSpace () {\n    if (hasTag && !nonSpace) {\n      while (spaces.length)\n        delete tokens[spaces.pop()];\n    } else {\n      spaces = [];\n    }\n\n    hasTag = false;\n    nonSpace = false;\n  }\n\n  var openingTagRe, closingTagRe, closingCurlyRe;\n  function compileTags (tagsToCompile) {\n    if (typeof tagsToCompile === 'string')\n      tagsToCompile = tagsToCompile.split(spaceRe, 2);\n\n    if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)\n      throw new Error('Invalid tags: ' + tagsToCompile);\n\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*');\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1]));\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1]));\n  }\n\n  compileTags(tags || mustache.tags);\n\n  var scanner = new Scanner(template);\n\n  var start, type, value, chr, token, openSection;\n  while (!scanner.eos()) {\n    start = scanner.pos;\n\n    // Match any text between tags.\n    value = scanner.scanUntil(openingTagRe);\n\n    if (value) {\n      for (var i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i);\n\n        if (isWhitespace(chr)) {\n          spaces.push(tokens.length);\n          indentation += chr;\n        } else {\n          nonSpace = true;\n          lineHasNonSpace = true;\n          indentation += ' ';\n        }\n\n        tokens.push([ 'text', chr, start, start + 1 ]);\n        start += 1;\n\n        // Check for whitespace on the current line.\n        if (chr === '\\n') {\n          stripSpace();\n          indentation = '';\n          tagIndex = 0;\n          lineHasNonSpace = false;\n        }\n      }\n    }\n\n    // Match the opening tag.\n    if (!scanner.scan(openingTagRe))\n      break;\n\n    hasTag = true;\n\n    // Get the tag type.\n    type = scanner.scan(tagRe) || 'name';\n    scanner.scan(whiteRe);\n\n    // Get the tag value.\n    if (type === '=') {\n      value = scanner.scanUntil(equalsRe);\n      scanner.scan(equalsRe);\n      scanner.scanUntil(closingTagRe);\n    } else if (type === '{') {\n      value = scanner.scanUntil(closingCurlyRe);\n      scanner.scan(curlyRe);\n      scanner.scanUntil(closingTagRe);\n      type = '&';\n    } else {\n      value = scanner.scanUntil(closingTagRe);\n    }\n\n    // Match the closing tag.\n    if (!scanner.scan(closingTagRe))\n      throw new Error('Unclosed tag at ' + scanner.pos);\n\n    if (type == '>') {\n      token = [ type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace ];\n    } else {\n      token = [ type, value, start, scanner.pos ];\n    }\n    tagIndex++;\n    tokens.push(token);\n\n    if (type === '#' || type === '^') {\n      sections.push(token);\n    } else if (type === '/') {\n      // Check section nesting.\n      openSection = sections.pop();\n\n      if (!openSection)\n        throw new Error('Unopened section \"' + value + '\" at ' + start);\n\n      if (openSection[1] !== value)\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start);\n    } else if (type === 'name' || type === '{' || type === '&') {\n      nonSpace = true;\n    } else if (type === '=') {\n      // Set the tags for the next time around.\n      compileTags(value);\n    }\n  }\n\n  stripSpace();\n\n  // Make sure there are no open sections when we're done.\n  openSection = sections.pop();\n\n  if (openSection)\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos);\n\n  return nestTokens(squashTokens(tokens));\n}\n\n/**\n * Combines the values of consecutive text tokens in the given `tokens` array\n * to a single token.\n */\nfunction squashTokens (tokens) {\n  var squashedTokens = [];\n\n  var token, lastToken;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    if (token) {\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        squashedTokens.push(token);\n        lastToken = token;\n      }\n    }\n  }\n\n  return squashedTokens;\n}\n\n/**\n * Forms the given array of `tokens` into a nested tree structure where\n * tokens that represent a section have two additional items: 1) an array of\n * all tokens that appear in that section and 2) the index in the original\n * template that represents the end of that section.\n */\nfunction nestTokens (tokens) {\n  var nestedTokens = [];\n  var collector = nestedTokens;\n  var sections = [];\n\n  var token, section;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i];\n\n    switch (token[0]) {\n      case '#':\n      case '^':\n        collector.push(token);\n        sections.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;\n        break;\n      default:\n        collector.push(token);\n    }\n  }\n\n  return nestedTokens;\n}\n\n/**\n * A simple string scanner that is used by the template parser to find\n * tokens in template strings.\n */\nfunction Scanner (string) {\n  this.string = string;\n  this.tail = string;\n  this.pos = 0;\n}\n\n/**\n * Returns `true` if the tail is empty (end of string).\n */\nScanner.prototype.eos = function eos () {\n  return this.tail === '';\n};\n\n/**\n * Tries to match the given regular expression at the current position.\n * Returns the matched text if it can match, the empty string otherwise.\n */\nScanner.prototype.scan = function scan (re) {\n  var match = this.tail.match(re);\n\n  if (!match || match.index !== 0)\n    return '';\n\n  var string = match[0];\n\n  this.tail = this.tail.substring(string.length);\n  this.pos += string.length;\n\n  return string;\n};\n\n/**\n * Skips all text until the given regular expression can be matched. Returns\n * the skipped string, which is the entire tail if no match can be made.\n */\nScanner.prototype.scanUntil = function scanUntil (re) {\n  var index = this.tail.search(re), match;\n\n  switch (index) {\n    case -1:\n      match = this.tail;\n      this.tail = '';\n      break;\n    case 0:\n      match = '';\n      break;\n    default:\n      match = this.tail.substring(0, index);\n      this.tail = this.tail.substring(index);\n  }\n\n  this.pos += match.length;\n\n  return match;\n};\n\n/**\n * Represents a rendering context by wrapping a view object and\n * maintaining a reference to the parent context.\n */\nfunction Context (view, parentContext) {\n  this.view = view;\n  this.cache = { '.': this.view };\n  this.parent = parentContext;\n}\n\n/**\n * Creates a new context using the given view with this context\n * as the parent.\n */\nContext.prototype.push = function push (view) {\n  return new Context(view, this);\n};\n\n/**\n * Returns the value of the given name in this context, traversing\n * up the context hierarchy if the value is absent in this context's view.\n */\nContext.prototype.lookup = function lookup (name) {\n  var cache = this.cache;\n\n  var value;\n  if (cache.hasOwnProperty(name)) {\n    value = cache[name];\n  } else {\n    var context = this, intermediateValue, names, index, lookupHit = false;\n\n    while (context) {\n      if (name.indexOf('.') > 0) {\n        intermediateValue = context.view;\n        names = name.split('.');\n        index = 0;\n\n        /**\n         * Using the dot notion path in `name`, we descend through the\n         * nested objects.\n         *\n         * To be certain that the lookup has been successful, we have to\n         * check if the last object in the path actually has the property\n         * we are looking for. We store the result in `lookupHit`.\n         *\n         * This is specially necessary for when the value has been set to\n         * `undefined` and we want to avoid looking up parent contexts.\n         *\n         * In the case where dot notation is used, we consider the lookup\n         * to be successful even if the last \"object\" in the path is\n         * not actually an object but a primitive (e.g., a string, or an\n         * integer), because it is sometimes useful to access a property\n         * of an autoboxed primitive, such as the length of a string.\n         **/\n        while (intermediateValue != null && index < names.length) {\n          if (index === names.length - 1)\n            lookupHit = (\n              hasProperty(intermediateValue, names[index])\n              || primitiveHasOwnProperty(intermediateValue, names[index])\n            );\n\n          intermediateValue = intermediateValue[names[index++]];\n        }\n      } else {\n        intermediateValue = context.view[name];\n\n        /**\n         * Only checking against `hasProperty`, which always returns `false` if\n         * `context.view` is not an object. Deliberately omitting the check\n         * against `primitiveHasOwnProperty` if dot notation is not used.\n         *\n         * Consider this example:\n         * ```\n         * Mustache.render(\"The length of a football field is {{#length}}{{length}}{{/length}}.\", {length: \"100 yards\"})\n         * ```\n         *\n         * If we were to check also against `primitiveHasOwnProperty`, as we do\n         * in the dot notation case, then render call would return:\n         *\n         * \"The length of a football field is 9.\"\n         *\n         * rather than the expected:\n         *\n         * \"The length of a football field is 100 yards.\"\n         **/\n        lookupHit = hasProperty(context.view, name);\n      }\n\n      if (lookupHit) {\n        value = intermediateValue;\n        break;\n      }\n\n      context = context.parent;\n    }\n\n    cache[name] = value;\n  }\n\n  if (isFunction(value))\n    value = value.call(this.view);\n\n  return value;\n};\n\n/**\n * A Writer knows how to take a stream of tokens and render them to a\n * string, given a context. It also maintains a cache of templates to\n * avoid the need to parse the same template twice.\n */\nfunction Writer () {\n  this.templateCache = {\n    _cache: {},\n    set: function set (key, value) {\n      this._cache[key] = value;\n    },\n    get: function get (key) {\n      return this._cache[key];\n    },\n    clear: function clear () {\n      this._cache = {};\n    }\n  };\n}\n\n/**\n * Clears all cached templates in this writer.\n */\nWriter.prototype.clearCache = function clearCache () {\n  if (typeof this.templateCache !== 'undefined') {\n    this.templateCache.clear();\n  }\n};\n\n/**\n * Parses and caches the given `template` according to the given `tags` or\n * `mustache.tags` if `tags` is omitted,  and returns the array of tokens\n * that is generated from the parse.\n */\nWriter.prototype.parse = function parse (template, tags) {\n  var cache = this.templateCache;\n  var cacheKey = template + ':' + (tags || mustache.tags).join(':');\n  var isCacheEnabled = typeof cache !== 'undefined';\n  var tokens = isCacheEnabled ? cache.get(cacheKey) : undefined;\n\n  if (tokens == undefined) {\n    tokens = parseTemplate(template, tags);\n    isCacheEnabled && cache.set(cacheKey, tokens);\n  }\n  return tokens;\n};\n\n/**\n * High-level method that is used to render the given `template` with\n * the given `view`.\n *\n * The optional `partials` argument may be an object that contains the\n * names and templates of partials that are used in the template. It may\n * also be a function that is used to load partial templates on the fly\n * that takes a single argument: the name of the partial.\n *\n * If the optional `config` argument is given here, then it should be an\n * object with a `tags` attribute or an `escape` attribute or both.\n * If an array is passed, then it will be interpreted the same way as\n * a `tags` attribute on a `config` object.\n *\n * The `tags` attribute of a `config` object must be an array with two\n * string values: the opening and closing tags used in the template (e.g.\n * [ \"<%\", \"%>\" ]). The default is to mustache.tags.\n *\n * The `escape` attribute of a `config` object must be a function which\n * accepts a string as input and outputs a safely escaped string.\n * If an `escape` function is not provided, then an HTML-safe string\n * escaping function is used as the default.\n */\nWriter.prototype.render = function render (template, view, partials, config) {\n  var tags = this.getConfigTags(config);\n  var tokens = this.parse(template, tags);\n  var context = (view instanceof Context) ? view : new Context(view, undefined);\n  return this.renderTokens(tokens, context, partials, template, config);\n};\n\n/**\n * Low-level method that renders the given array of `tokens` using\n * the given `context` and `partials`.\n *\n * Note: The `originalTemplate` is only ever used to extract the portion\n * of the original template that was contained in a higher-order section.\n * If the template doesn't use higher-order sections, this argument may\n * be omitted.\n */\nWriter.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate, config) {\n  var buffer = '';\n\n  var token, symbol, value;\n  for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    value = undefined;\n    token = tokens[i];\n    symbol = token[0];\n\n    if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate, config);\n    else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate, config);\n    else if (symbol === '>') value = this.renderPartial(token, context, partials, config);\n    else if (symbol === '&') value = this.unescapedValue(token, context);\n    else if (symbol === 'name') value = this.escapedValue(token, context, config);\n    else if (symbol === 'text') value = this.rawValue(token);\n\n    if (value !== undefined)\n      buffer += value;\n  }\n\n  return buffer;\n};\n\nWriter.prototype.renderSection = function renderSection (token, context, partials, originalTemplate, config) {\n  var self = this;\n  var buffer = '';\n  var value = context.lookup(token[1]);\n\n  // This function is used to render an arbitrary template\n  // in the current context by higher-order sections.\n  function subRender (template) {\n    return self.render(template, context, partials, config);\n  }\n\n  if (!value) return;\n\n  if (isArray(value)) {\n    for (var j = 0, valueLength = value.length; j < valueLength; ++j) {\n      buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);\n    }\n  } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {\n    buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);\n  } else if (isFunction(value)) {\n    if (typeof originalTemplate !== 'string')\n      throw new Error('Cannot use higher-order sections without the original template');\n\n    // Extract the portion of the original template that the section contains.\n    value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);\n\n    if (value != null)\n      buffer += value;\n  } else {\n    buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);\n  }\n  return buffer;\n};\n\nWriter.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate, config) {\n  var value = context.lookup(token[1]);\n\n  // Use JavaScript's definition of falsy. Include empty arrays.\n  // See https://github.com/janl/mustache.js/issues/186\n  if (!value || (isArray(value) && value.length === 0))\n    return this.renderTokens(token[4], context, partials, originalTemplate, config);\n};\n\nWriter.prototype.indentPartial = function indentPartial (partial, indentation, lineHasNonSpace) {\n  var filteredIndentation = indentation.replace(/[^ \\t]/g, '');\n  var partialByNl = partial.split('\\n');\n  for (var i = 0; i < partialByNl.length; i++) {\n    if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n      partialByNl[i] = filteredIndentation + partialByNl[i];\n    }\n  }\n  return partialByNl.join('\\n');\n};\n\nWriter.prototype.renderPartial = function renderPartial (token, context, partials, config) {\n  if (!partials) return;\n  var tags = this.getConfigTags(config);\n\n  var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];\n  if (value != null) {\n    var lineHasNonSpace = token[6];\n    var tagIndex = token[5];\n    var indentation = token[4];\n    var indentedValue = value;\n    if (tagIndex == 0 && indentation) {\n      indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);\n    }\n    var tokens = this.parse(indentedValue, tags);\n    return this.renderTokens(tokens, context, partials, indentedValue, config);\n  }\n};\n\nWriter.prototype.unescapedValue = function unescapedValue (token, context) {\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return value;\n};\n\nWriter.prototype.escapedValue = function escapedValue (token, context, config) {\n  var escape = this.getConfigEscape(config) || mustache.escape;\n  var value = context.lookup(token[1]);\n  if (value != null)\n    return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape(value);\n};\n\nWriter.prototype.rawValue = function rawValue (token) {\n  return token[1];\n};\n\nWriter.prototype.getConfigTags = function getConfigTags (config) {\n  if (isArray(config)) {\n    return config;\n  }\n  else if (config && typeof config === 'object') {\n    return config.tags;\n  }\n  else {\n    return undefined;\n  }\n};\n\nWriter.prototype.getConfigEscape = function getConfigEscape (config) {\n  if (config && typeof config === 'object' && !isArray(config)) {\n    return config.escape;\n  }\n  else {\n    return undefined;\n  }\n};\n\nvar mustache = {\n  name: 'mustache.js',\n  version: '4.2.0',\n  tags: [ '{{', '}}' ],\n  clearCache: undefined,\n  escape: undefined,\n  parse: undefined,\n  render: undefined,\n  Scanner: undefined,\n  Context: undefined,\n  Writer: undefined,\n  /**\n   * Allows a user to override the default caching strategy, by providing an\n   * object with set, get and clear methods. This can also be used to disable\n   * the cache by setting it to the literal `undefined`.\n   */\n  set templateCache (cache) {\n    defaultWriter.templateCache = cache;\n  },\n  /**\n   * Gets the default or overridden caching object from the default writer.\n   */\n  get templateCache () {\n    return defaultWriter.templateCache;\n  }\n};\n\n// All high-level mustache.* functions use this writer.\nvar defaultWriter = new Writer();\n\n/**\n * Clears all cached templates in the default writer.\n */\nmustache.clearCache = function clearCache () {\n  return defaultWriter.clearCache();\n};\n\n/**\n * Parses and caches the given template in the default writer and returns the\n * array of tokens it contains. Doing this ahead of time avoids the need to\n * parse templates on the fly as they are rendered.\n */\nmustache.parse = function parse (template, tags) {\n  return defaultWriter.parse(template, tags);\n};\n\n/**\n * Renders the `template` with the given `view`, `partials`, and `config`\n * using the default writer.\n */\nmustache.render = function render (template, view, partials, config) {\n  if (typeof template !== 'string') {\n    throw new TypeError('Invalid template! Template should be a \"string\" ' +\n                        'but \"' + typeStr(template) + '\" was given as the first ' +\n                        'argument for mustache#render(template, view, partials)');\n  }\n\n  return defaultWriter.render(template, view, partials, config);\n};\n\n// Export the escaping function so that the user may override it.\n// See https://github.com/janl/mustache.js/issues/244\nmustache.escape = escapeHtml;\n\n// Export these mainly for testing, but also for advanced usage.\nmustache.Scanner = Scanner;\nmustache.Context = Context;\nmustache.Writer = Writer;\n\nexport default mustache;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * Instantiates the frontend and binds it to the window.\n */\nimport FormBase from './form/form-base';\nimport Frontend from './frontend';\nimport Constants from './constants';\n\n// bind frontend to window\nwindow.StaticSnapFrontend = new Frontend();\n\n/**\n * This is used to avoid code duplication in the frontend and extensions.\n * Creating this and adding '@staticsnap/frontend': 'StaticSnapFrontendClasses' to webpack externals\n * allows us to import the classes from the frontend in the extensions without duplicating the code.\n */\nwindow.StaticSnapFrontendClasses = {\n  FormBase,\n  Constants,\n};\n"],"names":["Constants","defaultSearchInputSelector","defaultSearchResultsSelector","Events","FORM_SUBMITTED_EVENT","FORM_SUBMIT_ERROR_EVENT","__","FormBase","forms","selector","submitButtonSelector","constructor","includes","StaticSnapFrontendConfig","captcha_type","loadGoogleRecaptcha","loadPowCaptcha","bindEvents","getFormSettings","responseData","defaultSettings","messages","error","invalid","required","success","type","data","websiteForm","website_form_settings","getNoticeMessageSettings","form","defaultMessageSettings","error_message","invalid_message","required_field_message","success_message","messageSettings","dataset","staticSnapFormNoticeSettings","JSON","parse","_e","getNoticeMessageOrRedirect","redirect_url","messageMap","field_error","invalid_error","script","document","createElement","src","async","defer","head","appendChild","captcha_site_key","getForms","querySelectorAll","unbindSubmitEvents","setTimeout","jQuery","off","forEach","getAttribute","powcaptchaWidget","setAttribute","bindPowCaptchaEvents","addEventListener","e","submit","signalsReady","haveError","timeoutMs","console","resolveIfSignalsAreReady","isLoading","isValidated","execute","fields","field","beforeSubmit","isFormValid","checkValidity","reportValidity","event","preventDefault","querySelector","submitFormDataWithCaptcha","token","grecaptcha","action","formData","FormData","submitData","Object","fromEntries","response","fetch","body","stringify","headers","method","responseCode","status","json","removeAttribute","reset","dispatchEvent","CustomEvent","detail","onSubmit","onError","ready","Search","FuseSearch","Frontend","addModule","config","defaultConfig","has_translations","is_admin_bar_showing","is_static","locale","options","search","frontend_settings","settings","search_index_url","window","key","keyIndex","SearchBox","modules","frontend","frontendSearchSettings","searchBox","search_selector","search_results_selector","module","push","getSearchModule","searchModuleType","searchModule","filter","getType","Error","query","renderResults","target","results","getSearchBox","Fuse","Mustache","fuse","searchData","searchIndex","fuse_options","distance","findAllMatches","ignoreFieldNorm","ignoreLocation","includeScore","keys","shouldSort","threshold","useExtendedSearch","getFuse","extendedQuery","$and","$or","title","content","excerpt","language","getOptions","startsWith","option","replace","value","getSearchIndex","force","createIndex","template","getElementById","innerHTML","rendered","html","map","result","render","item","join","elements","searchResultsSelector","initDomEvents","bind","getElements","Array","from","element","closest","searchParams","URLSearchParams","location","get","onSearch","Event","onPopState","_event","blur","isTrusted","set","history","pushState","q","pathname","toString","renderTarget","className","parentSearch","StaticSnapFrontend","StaticSnapFrontendClasses"],"sourceRoot":""}